{"version":3,"sources":["functions/radioApi.ts","components/search.tsx","components/stationList.tsx","functions/lastPlayed.ts","functions/radioPlayer.ts","functions/favorites.ts","components/slider.tsx","models/base.ts","models/range.ts","components/player.tsx","components/about.tsx","webradio.tsx","index.tsx"],"names":["toStation","r","name","id","stationuuid","tags","country","language","icon","favicon","votes","codec","bitrate","RadioSearch","query","offset","results","this","undefined","limit","url","apiUrl","fetch","then","res","json","map","push","getStreamUrl","station","a","ok","refreshStation","voteForStation","needsUpgrade","upgradeStation","refreshed","currentSearch","StationList","stations","props","className","onClick","onStationSelected","key","React","Component","Search","searchTimer","searchList","state","search","searching","createRef","e","target","value","scheduleSearch","clearTimeout","setTimeout","setState","current","scrollTop","radioSearch","defaultValue","onInput","searchTextChanged","ref","getLastPlayedStation","stat","localStorage","getItem","JSON","parse","saveLastPlayedStation","setItem","stringify","LoadError","message","Error","RadioPlayer","player","statusEmitter","loading","_volume","off","stop","unload","fireStatusChange","loadPlayer","Howl","src","autoplay","html5","preload","on","_","error","playing","volume","play","newStatus","detail","cb","idx","findIndex","val","splice","vol","favorites","updateCbs","isFavorite","save","find","changed","stats","upgrades","length","Promise","all","ucb","Slider","valueChangeSub","posStartDrag","valStart","sliderBg","dragging","model","subscribe","unsubscribe","sliderWidth","clientWidth","offs","clientX","change","max","min","setPointerCapture","pointerId","left","style","top","width","height","position","onPointerDown","onPointerMove","onPointerUp","SubscriptionRepository","subs","Map","changeFunc","subsForName","get","set","sub","onChange","newVal","RangeModel","_min","_max","_val","updateValue","prop","add","notifyFor","radioPlayer","Player","status","voting","statusChangeId","onStatusChanged","offStatusChanged","getPlayStatus","setStation","remove","detailText","playButtonText","load","getPlayDetail","togglePlayback","toggleFavorite","vote","disabled","About","href","WebradioApp","selectedTab","onUpdated","lastPlayed","stationSelected","tab","userSelect","title","selectedStation","changeTab","tabs","selectedTabName","headerContent","tabElements","content","cls","list","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2a203278.chunk.js","sourcesContent":["\r\nexport interface Query {\r\n    name: string;\r\n    tags?: string;\r\n    limit?: number;\r\n}\r\n\r\nexport interface Station {\r\n    name: string\r\n    id: string,\r\n    tags: string,\r\n    country: string,\r\n    language: string,\r\n    icon: string,\r\n    votes: number,\r\n    // fields below are added to v1\r\n    codec:string,              \r\n    bitrate:number,            \r\n}\r\n\r\n/// station format from api.radio-browser\r\ninterface RadioStation { \r\n    /** A globally unique identifier for the change of the station information */\r\n    changeuuid:string,         \r\n    /**A globally unique identifier for the station */\r\n    stationuuid:string,        \r\n    /**  The name of the station */\r\n    name:string, \t           \r\n    /**  URL (HTTP/HTTPS) \tThe stream URL provided by the user*/\r\n    url:string,                \r\n    /** URL (HTTP/HTTPS) \tAn automatically \"resolved\" stream URL. Things resolved are playlists (M3U/PLS/ASX...), HTTP redirects (Code 301/302). This link is especially usefull if you use this API from a platform that is not able to do a resolve on its own (e.g. JavaScript in browser) or you just don't want to invest the time in decoding playlists yourself. */\r\n    url_resolved:string,       \r\n    /** URL (HTTP/HTTPS) \tURL to the homepage of the stream, so you can direct the user to a page with more information about the stream. */\r\n    homepage:string,           \r\n    /**  URL (HTTP/HTTPS) \tURL to an icon or picture that represents the stream. (PNG, JPG)*/\r\n    favicon:string,            \r\n    /** multivalue, split by comma \tTags of the stream with more information about it */\r\n    tags:string,               \r\n    /** DEPRECATED: use countrycode instead, full name of the country */ \r\n    country:string             \r\n    /** 2 letters, uppercase \tOfficial countrycodes as in ISO 3166-1 alpha-2 */\r\n    countrycode:string,        \r\n    /**  Full name of the entity where the station is located inside the country*/\r\n    state:string,              \r\n    /** multivalue, split by comma \tLanguages that are spoken in this stream. */\r\n    language:string,           \r\n    /** integer \tNumber of votes for this station. This number is by server and only ever increases. It will never be reset to 0. */\r\n    votes:number,              \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tLast time when the stream information was changed in the database */\r\n    lastchangetime:string,     \r\n    /** The codec of this stream recorded at the last check. */\r\n    codec:string,              \r\n    /** integer, bps \tThe bitrate of this stream recorded at the last check. */\r\n    bitrate:number,            \r\n    /** 0 or 1 \tMark if this stream is using HLS distribution or non-HLS. */\r\n    hls:number,                \r\n    /** 0 or 1 \tThe current online/offline state of this stream. This is a value calculated from multiple measure points in the internet. \r\n     * The test servers are located in different countries. It is a majority vote. */\r\n    lastcheckok: number        \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when any radio-browser server checked the online state of this stream */\r\n    lastchecktime:string,      \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when the stream was checked for the online status with a positive result */\r\n    lastcheckoktime:string,    \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when this server checked the online state and the metadata of this stream */\r\n    lastlocalchecktime:string, \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe time of the last click recorded for this stream */\r\n    clicktimestamp:string,     \r\n    /** integer \tClicks within the last 24 hours */\r\n    clickcount:number,         \r\n    /** integer \tThe difference of the clickcounts within the last 2 days. Posivite values mean an increase, negative a decrease of clicks. */\r\n    clicktrend:number,         \r\n}\r\n\r\nfunction toStation(r:RadioStation):Station {\r\n    return {  name: r.name,\r\n              id: r.stationuuid,\r\n              tags: r.tags,\r\n              country: r.country,\r\n              language: r.language,\r\n              icon: r.favicon,\r\n              votes: r.votes,\r\n              codec: r.codec,\r\n              bitrate: r.bitrate\r\n    }\r\n}\r\n\r\n// api docs at: https://api.radio-browser.info/\r\n// and https://de1.api.radio-browser.info/#Advanced_station_search\r\nexport class RadioSearch {\r\n    public query: Query\r\n    private offset = 0\r\n\r\n    results:Station[] = []\r\n    constructor(query: Query) {\r\n        this.query = query\r\n        if (this.query.limit == undefined)\r\n            this.query.limit = 20\r\n    }\r\n\r\n    async search() {\r\n        // compute url\r\n        let url = `${apiUrl}/stations/search?name=${this.query.name}&order=votes&reverse=true&limit=${this.query.limit}&offset=${this.offset}`\r\n        // do the stuff\r\n        let results = await fetch(url).then(res => res.json())\r\n        let res:Station[] = results.map(toStation)\r\n        this.results.push(...res)\r\n    }\r\n}\r\n\r\nexport async function getStreamUrl(station:Station) {\r\n    var url = `${apiUrl}/url/${station.id}`;\r\n    var res = await fetch(url).then(res=>res.json())\r\n    if (res && res.ok)\r\n        return res.url as string;\r\n    else return undefined;\r\n}\r\n\r\nexport async function refreshStation(station:Station) {\r\n    var url = `${apiUrl}/stations/byuuid/${station.id}` // get info for this station only\r\n    var res = await fetch(url).then(res=>res.json())\r\n    // will return an array with one item\r\n    if (res && res[0]) {\r\n        return toStation(res[0])\r\n    }\r\n}\r\n\r\nexport async function voteForStation(station:Station) {\r\n    var url = `${apiUrl}/vote/${station.id}`; \r\n    // will return status of vote (in the ok field)\r\n    try {\r\n        var res = await fetch(url)\r\n        if (res.ok) {\r\n            res = await res.json()\r\n            return res.ok\r\n        } else return false\r\n    } catch (err) {\r\n        return false\r\n    }\r\n}\r\n\r\nconst apiUrl = \"https://de1.api.radio-browser.info/json\" // todo: should do dns lookup as the docs ask\r\n\r\nexport function needsUpgrade(station:Station) {\r\n    // from v0 to v1 (codec and bitrate added)\r\n    return station.codec == undefined || station.bitrate == undefined;\r\n}\r\n\r\nexport async function upgradeStation(station:Station) {\r\n    let refreshed = await refreshStation(station)\r\n    if (refreshed) {\r\n        station.codec = refreshed.codec;\r\n        station.bitrate = refreshed.bitrate;\r\n        // could refresh all fields but only these have been added\r\n        return true\r\n    }\r\n    return false\r\n}","import React from 'react';\r\nimport { RadioSearch, Station } from '../functions/radioApi';\r\nimport StationList from './stationList';\r\n\r\ninterface SearchState {\r\n    search: RadioSearch|undefined\r\n    searching:boolean\r\n}\r\n\r\ninterface SearchProps {\r\n    onStationSelected?:(station:Station)=> any\r\n    className?: string\r\n}\r\n\r\nlet currentSearch:RadioSearch|undefined // only one search active at a time\r\n\r\nexport default class Search extends React.Component<SearchProps, SearchState> {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            search: currentSearch,\r\n            searching: false\r\n        }\r\n        this.searchList = React.createRef<HTMLDivElement>()\r\n    }\r\n\r\n    async searchTextChanged(e) {\r\n        const query = e.target.value;\r\n        this.scheduleSearch(query)\r\n    }\r\n\r\n    private searchTimer\r\n    private searchList:React.RefObject<HTMLDivElement>\r\n\r\n    async scheduleSearch(query:string) {\r\n        this.searchTimer = clearTimeout(this.searchTimer)\r\n        this.searchTimer = setTimeout(async () => {\r\n            let search = new RadioSearch({name: query})\r\n            currentSearch = search\r\n            this.setState({searching: true})\r\n            await search.search()\r\n            // reset scroll\r\n            if (this.searchList.current) this.searchList.current.scrollTop = 0\r\n            this.setState({\r\n                search,\r\n                searching: false\r\n            })\r\n        }, 400)\r\n    }\r\n\r\n    render() {\r\n        const radioSearch = this.state.search; \r\n        let results:Station[]|undefined \r\n        if (radioSearch) {\r\n            results = radioSearch.results\r\n        }\r\n        let searching = this.state.searching ? <span className=\"loading\">Searching...</span> : undefined\r\n        return (\r\n            <div className={\"search flexible vertical \" + (this.props.className ?? \"\")}>\r\n                <div className=\"flexible horizontal\">\r\n                    <input className=\"flex1\" defaultValue={radioSearch ? radioSearch.query.name : \"\"} \r\n                      onInput={ (e) => { this.searchTextChanged(e) } }></input>\r\n                    {searching}\r\n                </div>\r\n                \r\n                <div ref={this.searchList} className=\"results scrollable\">\r\n                    <StationList stations={results} onStationSelected={this.props?.onStationSelected}></StationList>\r\n                </div>\r\n                \r\n            </div>\r\n        )\r\n    }\r\n}","import React from \"react\"\r\nimport { Station } from \"../functions/radioApi\";\r\n\r\ninterface StationsProps {\r\n    stations?: Station[]\r\n    onStationSelected?: (station:Station) => any\r\n}\r\n\r\nexport default class StationList extends React.Component<StationsProps, {}> {\r\n    render() {\r\n        const stations = this.props.stations;\r\n        if (stations) {\r\n            let results = stations.map(station => \r\n                                               <div className=\"clickable\" onClick={ () => this.props?.onStationSelected?.(station) } key={station.id}>\r\n                                                 <div className=\"flexible horizontal station-header\">\r\n                                                    <h3>{station.name}</h3>\r\n                                                    <span>{station.votes}</span>\r\n                                                 </div>\r\n                                                 <div>{station.tags}</div>\r\n                                                 <div className=\"flexible horizontal\">\r\n                                                     <span className=\"flex1\">{station.country}</span>\r\n                                                     <span className=\"bold codec\">{station.codec} </span>\r\n                                                     <span>{station.bitrate} kbps</span>\r\n                                                 </div>\r\n                                                 <hr></hr>\r\n                                               </div> )\r\n            return results\r\n        } else return null\r\n    }\r\n}","import { Station, needsUpgrade, upgradeStation } from \"./radioApi\";\r\n\r\nexport async function getLastPlayedStation():Promise<Station | undefined> {\r\n    const stat = localStorage.getItem(\"lastPlayed\")\r\n    if (stat) {\r\n        let station:Station = JSON.parse(stat)\r\n        if (needsUpgrade(station))\r\n            await upgradeStation(station)\r\n        return station\r\n    }\r\n}\r\n\r\nexport function saveLastPlayedStation(station:Station) {\r\n    localStorage.setItem(\"lastPlayed\", JSON.stringify(station))\r\n}","import { Howl } from \"howler\"\r\nimport { Station, getStreamUrl } from \"./radioApi\"\r\nimport { saveLastPlayedStation } from \"./lastPlayed\"\r\n\r\nexport type StatusCallback = (status:string, detail?:string)=>any\r\n\r\nexport class LoadError extends Error{\r\n    constructor(message:string) {\r\n        super(message)\r\n        this.name = \"LoadError\"\r\n    }\r\n}\r\n\r\nexport default class RadioPlayer {\r\n    player:Howl|undefined\r\n    station:Station|undefined\r\n    private statusEmitter:StatusCallback[] = []\r\n    private loading:Promise<void>|undefined\r\n\r\n    async setStation(station:Station) {\r\n        // stop old player\r\n        if (this.player) {\r\n            this.player.off() // remove old events, and stop\r\n            this.player.stop()\r\n            this.player.unload()\r\n            this.player = undefined\r\n        }\r\n        this.fireStatusChange(\"load\", \"station\")\r\n        this.station = station\r\n        \r\n        saveLastPlayedStation(station)\r\n        // will save loading promise, as users may use play while station url is loading\r\n        // in these cases play should progress as well (see play)\r\n        this.loading = this.loadPlayer(station)\r\n        return this.loading\r\n    }\r\n\r\n    private async loadPlayer(station:Station) {\r\n        // get station url ...\r\n        let url = await getStreamUrl(station)\r\n        this.loading = undefined\r\n        if (!url) {\r\n            this.fireStatusChange(\"error\", \"cannot resolve station url\")\r\n            throw new LoadError(\"cannot resolve station url\")\r\n        } \r\n        if (this.station?.id == station.id) { // haven't changed stations meanwhile\r\n            if (this.player) {\r\n                this.player.off()\r\n                this.player.unload() // if somehow an old player gets stuck, unload it\r\n            }\r\n            this.player = new Howl({src: url, autoplay: false, html5: true, preload: false})\r\n            this.fireStatusChange(\"stop\")\r\n            this.player.on('load', ()=> this.fireStatusChange(\"load\", \"start playing\"))\r\n            this.player.on('play', ()=> this.fireStatusChange(\"play\") )\r\n            this.player.on('stop', ()=> this.fireStatusChange(\"stop\") )\r\n            this.player.on('pause', ()=> this.fireStatusChange(\"stop\") )\r\n\r\n            // NOTE: howl will fire load errors for radio streams, without extension, if you call the `load()` method\r\n            //       this is probably a bug? (as play will report no errors)\r\n            this.player.on('loaderror', (_, error)=> this.fireStatusChange(\"error\", \"loading the stream failed: \" + error))\r\n            this.player.on('playerror', (_, error)=> this.fireStatusChange(\"error\", \"playback error: \" + error))\r\n        } else {\r\n            throw new LoadError(\"changed stations while loading\")\r\n        }\r\n    }\r\n\r\n    async play() {\r\n        try {\r\n            if (this.loading)\r\n                await this.loading\r\n        } catch (err) {\r\n            if (err instanceof LoadError)\r\n                return; // can't play this stream\r\n            else throw err // rethrow other errors\r\n        }\r\n        \r\n        if (this.player && !this.player.playing()) {\r\n            // when not loaded\r\n            if (this.player.state() == \"unloaded\") {\r\n                this.fireStatusChange(\"load\", \"stream\")\r\n                // no need to use `load`, see the loadError remark. play will load the stream\r\n            }\r\n            this.player.volume(this._volume / 100)\r\n            this.player.play()\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if (this.player) {\r\n            this.player.stop()\r\n            this.player.unload() // preserve battery\r\n        }\r\n    }\r\n\r\n    private _volume:number = 100\r\n    // set the volume in 0 to 100 range\r\n    set volume(vol:number) {\r\n        this._volume = vol\r\n        if (this.player) {\r\n            this.player.volume(vol / 100) // howler works with 0 and 1 range\r\n        }\r\n    }\r\n\r\n    private fireStatusChange(newStatus:string, detail?:string) {\r\n        for (let cb of this.statusEmitter) {\r\n            cb(newStatus, detail)\r\n        }\r\n    }\r\n\r\n    onStatusChanged(cb: StatusCallback) {\r\n        this.statusEmitter.push(cb)\r\n        return cb\r\n    }\r\n\r\n    offStatusChanged(cb:StatusCallback) {\r\n        const idx = this.statusEmitter.findIndex(val => cb == val)\r\n        if (idx >= 0)\r\n            this.statusEmitter.splice(idx, 1)\r\n    }\r\n}","import { Station, needsUpgrade, upgradeStation } from \"./radioApi\";\r\n\r\nexport type UpdateCallback = () => any\r\n\r\n// uses localStorage to keep a list of favorite stations\r\nclass Favorites {\r\n    private stations:Station[] = []\r\n    \r\n    add(station:Station) {\r\n        if (!this.isFavorite(station)) {\r\n            this.stations.push(station)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    remove(station:Station) {\r\n        const idx = this.stations.findIndex(val => val.id == station.id)\r\n        if (idx >= 0) {\r\n            this.stations.splice(idx, 1)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    isFavorite(station:Station):boolean {\r\n        const stat = this.stations.find(val => val.id == station.id)\r\n        return stat != undefined\r\n    }\r\n\r\n    get list() {\r\n        return this.stations\r\n    }\r\n\r\n    private save() { // save to local storage\r\n        localStorage.setItem(\"stations\", JSON.stringify(this.stations))\r\n        this.changed()\r\n    }\r\n\r\n    async load() { // load from local storage\r\n        let stats = localStorage.getItem(\"stations\")\r\n        if (stats) {\r\n            let stations:Station[] = JSON.parse(stats)\r\n            // check for upgrades\r\n            let upgrades:Promise<boolean>[] = []\r\n            for (let station of stations) {\r\n                if (needsUpgrade(station)) {\r\n                    upgrades.push(upgradeStation(station))\r\n                }\r\n            }\r\n            try {\r\n                if (upgrades.length) {\r\n                    await Promise.all(upgrades)\r\n                    this.stations = stations\r\n                    this.save() // save upgraded stations, so next time they don't have to be upgraded\r\n                }\r\n            } finally {\r\n                if (this.stations != stations) {\r\n                    this.stations = stations\r\n                    this.changed()\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateCbs:UpdateCallback[] = []\r\n    onUpdated(ucb:UpdateCallback):UpdateCallback {\r\n        this.updateCbs.push(ucb)\r\n        return ucb\r\n    }\r\n\r\n    private changed() {\r\n        for (const cb of this.updateCbs)\r\n            cb()\r\n    }\r\n}\r\n\r\nexport const favorites = new Favorites()","import React from \"react\"\r\nimport { RangeModel } from \"../models/range\"\r\nimport { Subscription } from \"../models/base\"\r\n\r\ninterface SliderProps {\r\n    model:RangeModel\r\n}\r\n\r\nexport class Slider extends React.Component<SliderProps> {\r\n    get model() { return this.props.model }\r\n    private valueChangeSub:Subscription|undefined\r\n\r\n    componentDidMount() {\r\n        this.valueChangeSub = this.model.subscribe(\"value\", () => {\r\n            this.setState({}) // value change, has to rerender\r\n        })\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.valueChangeSub) this.valueChangeSub.unsubscribe()\r\n    }\r\n\r\n    private posStartDrag = 0\r\n    private valStart = 0\r\n    private sliderBg = React.createRef<HTMLDivElement>()\r\n    private dragging = false\r\n\r\n    onPointerMove(e:React.PointerEvent) {\r\n        if (this.dragging && this.sliderBg.current) {\r\n            \r\n            const sliderWidth = this.sliderBg.current.clientWidth // corresponds to change in range max - min\r\n            let offs = e.clientX - this.posStartDrag\r\n            if (sliderWidth > 0) {\r\n                let change = offs * (this.model.max - this.model.min) / sliderWidth\r\n                this.model.val = this.valStart + change // this will update the display automatically\r\n            }\r\n        }\r\n    }\r\n\r\n    onPointerDown(e:React.PointerEvent) {\r\n        // todo: check button/finger here\r\n        this.posStartDrag = e.clientX\r\n        this.valStart = this.model.val;\r\n        (e.target as any).setPointerCapture(e.pointerId) // move events will be forwarded to this item, as expected\r\n                                                         // see: https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events#Pointer_capture\r\n        this.dragging = true\r\n    }\r\n\r\n    onPointerUp(e:React.PointerEvent) {\r\n        this.dragging = false\r\n    }\r\n\r\n    render() {\r\n        let model = this.model;\r\n        const left = (model.val - model.min) * 100 / (model.max - model.min) // left pos in percentage\r\n\r\n        return <div className=\"slider bg\" ref={this.sliderBg}>\r\n                    <div style={ { left: `${left}%`, top:\"50%\", width:0, height:0, position:\"absolute\"  } }>\r\n                        <span className=\"thumb\" onPointerDown={e=>this.onPointerDown(e)} onPointerMove={e=>this.onPointerMove(e)} onPointerUp={e=> this.onPointerUp(e)} ></span>\r\n                    </div>\r\n               </div>\r\n    }\r\n}","export interface Subscription {\r\n    unsubscribe():void\r\n}\r\n\r\nexport interface Subscriber<T> {\r\n    onChange(newVal:T):void\r\n}\r\n\r\nexport class SubscriptionRepository {\r\n    add(name:string, changeFunc:(newVal:any) => void):Subscription {\r\n        let subsForName = this.subs.get(name) || []\r\n        if (subsForName.length == 0) {\r\n            this.subs.set(name, subsForName)\r\n        }\r\n\r\n        let sub = { onChange: changeFunc }\r\n        subsForName.push(sub)\r\n        return {\r\n            unsubscribe: () => {\r\n                const idx = subsForName.findIndex(val => val == sub)\r\n                if (idx >= 0) subsForName.splice(idx)\r\n            }\r\n        }\r\n    }\r\n\r\n    notifyFor(name:string, newVal:any) {\r\n        let subsForName = this.subs.get(name)\r\n        if (subsForName)\r\n            for (let s of subsForName) s.onChange(newVal)\r\n    }\r\n\r\n    private subs = new Map<string, Subscriber<any>[]>()\r\n}\r\n\r\n","import { Subscription, SubscriptionRepository } from \"./base\"\r\n\r\n// model reperesenting range and value \r\nexport class RangeModel { \r\n    private _min:number = 0\r\n    private _max:number = 100\r\n    private _val:number = 0\r\n    \r\n    get val():number { return this._val }\r\n    get min():number { return this._min }\r\n    get max():number { return this._max }\r\n\r\n    set val(newVal:number) {\r\n        if (newVal < this._min) newVal = this._min\r\n        else if (newVal > this._max) newVal = this._max\r\n        this.updateValue(newVal)\r\n    }\r\n\r\n    /// replace range, if min or max is not given the old values are used\r\n    setRange(min:number|undefined, max:number|undefined) {\r\n        if (min == undefined) min = this._min\r\n        if (max == undefined) max = this._max\r\n        if (min >= max) \r\n            throw new Error(`Invalid range! (min < max) should hold. Got: ${min} >= ${max}`)\r\n        this._min = min\r\n        this._max = max\r\n        if (this._val < min)\r\n            this.updateValue(min)\r\n        else if (this._val > max)\r\n            this.updateValue(max)\r\n    }\r\n\r\n    // subscribe for changes in value\r\n    subscribe(prop:\"value\", changeFunc:(v:number) => void):Subscription {\r\n        return this.subs.add(prop, changeFunc)\r\n    }\r\n\r\n    private updateValue(newVal:number) {\r\n        if (this._val != newVal) {\r\n            this._val = newVal\r\n            this.subs.notifyFor(\"value\", newVal)\r\n        }\r\n    }\r\n\r\n    private subs = new SubscriptionRepository()\r\n}\r\n","import React from \"react\"\r\nimport { Station, voteForStation, refreshStation } from \"../functions/radioApi\"\r\nimport RadioPlayer, {StatusCallback, LoadError} from \"../functions/radioPlayer\"\r\nimport { favorites } from \"../functions/favorites\"\r\nimport { Slider } from \"./slider\"\r\nimport { RangeModel } from \"../models/range\"\r\n\r\nexport let radioPlayer = new RadioPlayer()\r\n\r\ninterface PlayerProps {\r\n    station:Station|undefined\r\n    className:string\r\n}\r\n\r\ninterface PlayerState {\r\n    status: string\r\n    detail?: string \r\n    voting: boolean\r\n}\r\n\r\nexport default class Player extends React.Component<PlayerProps, PlayerState> {\r\n    state:PlayerState = {\r\n        status : \"stop\",\r\n        voting: false\r\n    }\r\n\r\n    private statusChangeId:StatusCallback|undefined\r\n    private volume = new RangeModel()\r\n    componentDidMount() {\r\n        this.statusChangeId = radioPlayer.onStatusChanged((status, detail) => {\r\n            if (radioPlayer.station && this.props.station?.id == radioPlayer.station.id) // only change state, if we display details for the station playing\r\n                this.setState({\r\n                    status,\r\n                    detail\r\n                })\r\n        });\r\n\r\n        this.volume.val = 75; // // todo: should use persisted value and set to radio player\r\n        this.volume.subscribe(\"value\", vol => radioPlayer.volume = vol)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.statusChangeId)\r\n            radioPlayer.offStatusChanged(this.statusChangeId)\r\n    }\r\n\r\n    async togglePlayback() {\r\n        if (!this.props.station)\r\n            return\r\n        const stat = this.getPlayStatus()\r\n        if (stat != \"play\") {\r\n            try {\r\n                this.setState({status:\"load\", detail: undefined})\r\n                if (radioPlayer.station?.id != this.props.station.id)\r\n                    await radioPlayer.setStation(this.props.station)\r\n                radioPlayer.play()\r\n            } catch (loadErr) {\r\n                if (!(loadErr instanceof LoadError)) // no playback when loading fails. status change takes care of notifying the user\r\n                    throw loadErr\r\n            }\r\n        } else {\r\n            radioPlayer.stop()\r\n        }\r\n    }\r\n\r\n    getPlayStatus() {\r\n        let status = this.state.status // this can contain the last status updated by the player\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) {\r\n            status = \"stop\" // this stream hasn't been started\r\n        }\r\n        return status\r\n    }\r\n\r\n    getPlayDetail() {\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) \r\n            return undefined\r\n        else return this.state.detail\r\n    }\r\n\r\n    toggleFavorite() {\r\n        const station = this.props.station;\r\n        if (station) {\r\n            if (favorites.isFavorite(station)) favorites.remove(station)\r\n            else favorites.add(station)\r\n            this.setState({}) // needs update\r\n        }\r\n    }\r\n\r\n    async vote() {\r\n        if (!this.props.station) return\r\n        this.setState({voting: true})\r\n        const succ = await voteForStation(this.props.station)\r\n        \r\n        const refreshed = await refreshStation(this.props.station)\r\n        if (refreshed) {\r\n            this.props.station.votes = refreshed.votes\r\n        }\r\n        \r\n        this.setState({voting: false}) \r\n    }\r\n\r\n    render() {\r\n        const station = this.props.station;\r\n        if (!station) return null\r\n        let status = this.getPlayStatus()\r\n        \r\n        const buttonTextByStatus = {\r\n            play: \"Stop\",\r\n            stop: \"Play\",\r\n            load: \"Loading\",\r\n            error: `Error ${this.state.detail ?? \"\"}`\r\n        }\r\n        let playButtonText = buttonTextByStatus[status] ?? \"Error\"\r\n        let detailText:JSX.Element | undefined\r\n        const detail = this.getPlayDetail()\r\n        if (detail) {\r\n            detailText = <span>{detail}</span>\r\n        }\r\n\r\n        return <div className={this.props.className}>\r\n                    <h2>{station.name}</h2>\r\n                    <p>in: {station.country}</p>\r\n                    <p>tags: {station.tags}</p>\r\n                    <p><span className=\"bold codec\">{station.codec}</span>{station.bitrate} kbps</p>\r\n                    <div>\r\n                        <button onClick={e => this.togglePlayback()} >{playButtonText}</button> {/* toggle pause */}\r\n                        {detailText}\r\n                    </div>\r\n                    <div>\r\n                        <button onClick={()=> this.toggleFavorite()} >{favorites.isFavorite(station) ? \"Remove from favorites\" : \"Add to favorites\"}</button>\r\n                        <button onClick={()=> this.vote() }disabled={this.state.voting} >{this.state.voting ? \"Voting...\" : \"Vote!\"}</button>\r\n                        <span>{station.votes} votes</span>\r\n                    </div>\r\n                    <Slider model={this.volume} ></Slider>\r\n               </div>\r\n    }\r\n}","import React from 'react'\r\n\r\nexport default class About extends React.Component<{className:string}> {\r\n    render() {\r\n        return <div className={\"about \" + this.props.className} >\r\n            <h2>About</h2>\r\n            <p>\r\n                Open source webradio implementation using React. \r\n            </p>\r\n            <p>\r\n                Uses the api provided by <a href=\"http://www.radio-browser.info\">http://www.radio-browser.info</a>\r\n            </p>\r\n            <p>\r\n                If you find any issues, or have feature requests please report them at the project's github page: <a href=\"https://github.com/bxantus/webradio\">https://github.com/bxantus/webradio</a>\r\n            </p>\r\n            <hr></hr>\r\n            <h3>Link for mobile devices:</h3>\r\n            <img src=\"/webradio/address_qr.png\"></img>\r\n        </div>\r\n    }\r\n}","import React from 'react';\r\nimport RadioSearch from './components/search'\r\nimport RadioPlayerUI, { radioPlayer } from './components/player'\r\nimport { Station } from './functions/radioApi';\r\nimport About from './components/about';\r\nimport StationList from './components/stationList';\r\nimport { favorites } from './functions/favorites';\r\nimport { getLastPlayedStation } from './functions/lastPlayed';\r\n\r\ninterface RadioState {\r\n    selectedTab:string\r\n    selectedStation?:Station\r\n}\r\n\r\ninterface Tab {\r\n    title: string\r\n    content: (cls:string) => JSX.Element\r\n}\r\n\r\nexport default class WebradioApp extends React.Component<{}, RadioState> {\r\n    state:RadioState = {\r\n        selectedTab: \"Search\",\r\n    }\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        favorites.load();\r\n    }\r\n\r\n    async componentDidMount() {\r\n        favorites.onUpdated(() => {\r\n            this.setState({}) // update\r\n        })\r\n        const lastPlayed = await getLastPlayedStation()\r\n        if (lastPlayed) {\r\n            radioPlayer.setStation(lastPlayed)\r\n            this.stationSelected(lastPlayed) // switch to play tab\r\n        }\r\n    }\r\n\r\n    get tabs() {\r\n        return [\r\n            { title: \"Search\", content: (cls:string) => <RadioSearch className={cls} onStationSelected={station=> this.stationSelected(station)}>Search content</RadioSearch> },\r\n            { title: \"Favorites\", content: (cls:string) => <div className={\"scrollable \" + cls}><StationList stations={favorites.list} onStationSelected={station=> this.stationSelected(station)} ></StationList></div> },\r\n            { title: \"Play\", content: (cls:string) => <RadioPlayerUI className={cls} station={this.state.selectedStation}></RadioPlayerUI> },\r\n            { title: \"About\", content: (cls:string) => <About className={cls} ></About>}\r\n        ]\r\n    }\r\n\r\n    changeTab(tab:Tab, userSelect=true)  {\r\n        this.setState({\r\n            selectedTab: tab.title\r\n        })\r\n        if (userSelect) {\r\n            this.setState({\r\n                selectedStation: radioPlayer.station\r\n            })\r\n        }\r\n    }\r\n\r\n    stationSelected(station:Station) {\r\n        this.setState({\r\n            selectedStation: station\r\n        })\r\n        this.changeTab(this.tabs[2], /*userSelect*/false)  \r\n    }\r\n\r\n    render() {\r\n        const tabs = this.tabs\r\n        const selectedTabName = this.state.selectedTab\r\n        const selectedTab = tabs.find(tab => tab.title === selectedTabName)\r\n        const headerContent = tabs.map(tab => <span className={tab === selectedTab ? \"tab selected\" : \"tab\"}\r\n                                                    key={tab.title} onClick={e=>this.changeTab(tab)} >{tab.title}</span> )\r\n        const tabElements = tabs.map(tab => tab.content(tab == selectedTab ? \"visible\" : \"hidden\"))\r\n        \r\n        return (\r\n            <div className=\"radio-App flexible vertical\">\r\n                <div className=\"tabs\">{headerContent}</div>\r\n                {tabElements}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport WebRadio from './webradio'\n\nReactDOM.render(\n  <React.StrictMode>\n    <WebRadio>my text</WebRadio>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}