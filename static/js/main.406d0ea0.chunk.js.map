{"version":3,"sources":["components/stationList.tsx","components/search.tsx","functions/radioApi.ts","functions/lastPlayed.ts","models/base.ts","functions/radioPlayer.ts","functions/favorites.ts","components/slider.tsx","models/range.ts","components/player.tsx","components/about.tsx","webradio.tsx","functions/searchModel.ts","index.tsx"],"names":["StationList","stations","this","props","map","station","className","onClick","onStationSelected","key","id","name","tags","replace","country","length","src","votes","codec","bitrate","React","Component","Search","state","results","undefined","searching","search","subscribe","setState","res","document","scrollingElement","scrollTop","toStation","r","stationuuid","language","icon","favicon","RadioSearch","query","offset","_hasMoreResults","limit","url","apiUrl","fetch","then","json","push","getStreamUrl","a","refreshStation","voteForStation","ok","needsUpgrade","upgradeStation","refreshed","getLastPlayedStation","stat","localStorage","getItem","JSON","parse","saveLastPlayedStation","setItem","stringify","SubscriptionRepository","subs","Map","changeFunc","subsForName","get","set","sub","onChange","unsubscribe","idx","findIndex","val","splice","newVal","LoadError","message","Error","RadioPlayer","player","statusEmitter","loading","_volume","off","stop","unload","fireStatusChange","notifyFor","loadPlayer","Howl","autoplay","html5","preload","on","formatError","error","_","playing","volume","play","newStatus","detail","cb","prop","changeFn","add","vol","favorites","updateCbs","isFavorite","save","find","changed","stats","upgrades","Promise","all","ucb","Slider","valueChangeSub","posStartDrag","valStart","sliderBg","createRef","thumb","sliderProgress","dragging","moveListener","e","onPointerMove","upListener","onPointerUp","model","updateSliderStyles","current","setAttribute","trackSize","clientWidth","thumbWidth","pos","min","max","posCross","clientHeight","offs","clientX","change","window","addEventListener","removeEventListener","ref","onPointerDown","children","RangeModel","_min","_max","_val","updateValue","radioPlayer","Player","status","voting","displayError","statusChangeId","onStatusChanged","offStatusChanged","getPlayStatus","setStation","remove","buttonIcon","load","getPlayDetail","favoriteHeader","playButton","togglePlayback","errorBox","toggleFavorite","vote","disabled","draggable","About","target","href","currentSearch","searchTimer","timeout","clearTimeout","setTimeout","hasMoreResults","WebradioApp","tabs","title","content","cls","list","stationSelected","selectedStation","searchTab","scrollOffset","searchInput","focusOnSearch","selectedTab","onUpdated","lastPlayed","tab","userSelect","changeTab","value","scheduleSearch","focus","tabTitles","selection","tabContent","concat","searchSelected","defaultValue","searchText","onInput","searchTextChanged","selectSearch","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.406d0ea0.chunk.js","sourcesContent":["import React from \"react\"\r\nimport { Station } from \"../functions/radioApi\";\r\n\r\ninterface StationsProps {\r\n    stations?: Station[]\r\n    onStationSelected?: (station:Station) => any\r\n}\r\n\r\n// tags are retrieved in a format split by commas, but no preceding space\r\nfunction formatTags(tags:string) {\r\n    return tags.replace(/,(?=[^\\s])/g, \", \")\r\n}\r\n\r\nfunction formatCountry(country:string) {\r\n    return country.length > 0 ? country : \"Unknown\"\r\n}\r\n\r\nexport default class StationList extends React.Component<StationsProps, {}> {\r\n    render() {\r\n        const stations = this.props.stations;\r\n        if (stations) {\r\n            let results = stations.map(station => \r\n                <div className=\"clickable station\" onClick={ () => this.props?.onStationSelected?.(station) } key={station.id}>\r\n                    <h3>{station.name}</h3>\r\n                    <div className=\"tags\">{formatTags(station.tags)}</div>\r\n                    <div className=\"flexible horizontal details\">\r\n                        <span className=\"country\">{formatCountry(station.country)}</span>\r\n                        <img className=\"votes\" src=\"/webradio/icons/votes.svg\"></img>\r\n                        <span className=\"flex1\">{station.votes}</span>\r\n                        <span className=\"codec\">{station.codec} - {station.bitrate} kbps</span>\r\n                    </div>\r\n                    <hr></hr>\r\n                </div> )\r\n            return results\r\n        } else return null\r\n    }\r\n}","import React from 'react';\r\nimport { Station } from '../functions/radioApi';\r\nimport SearchModel from '../functions/searchModel'\r\nimport StationList from './stationList';\r\n\r\ninterface SearchState {\r\n    results: Station[] | undefined\r\n    searching:boolean\r\n}\r\n\r\ninterface SearchProps {\r\n    onStationSelected?:(station:Station)=> any\r\n    className?: string\r\n    search:SearchModel\r\n}\r\n\r\nexport default class Search extends React.Component<SearchProps, SearchState> {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            results: undefined, // todo: get current results from SearchModel\r\n            searching: false\r\n        }\r\n    }\r\n\r\n    componentWillMount() {\r\n        const search = this.props.search\r\n        search.subscribe(\"searching\", (searching:boolean)=> {\r\n            this.setState({searching: searching})\r\n        })\r\n        search.subscribe(\"results\", (res:Station[])=> {\r\n            this.setState({results: res})\r\n        })\r\n        search.subscribe(\"query\", ()=> {\r\n            if (document.scrollingElement)\r\n                document.scrollingElement.scrollTop = 0\r\n        })\r\n    }\r\n\r\n    render() {\r\n        const results = this.state.results\r\n        \r\n        // NOTE: based on `this.state.searching` we could present some searching progress\r\n        \r\n        return (\r\n            <div className={\"search flexible vertical \" + (this.props.className ?? \"\")}>\r\n                \r\n                <div className=\"results\">\r\n                    <StationList stations={results} onStationSelected={this.props?.onStationSelected}></StationList>\r\n                </div>\r\n                \r\n            </div>\r\n        )\r\n    }\r\n}","\r\nexport interface Query {\r\n    name: string;\r\n    tags?: string;\r\n    limit?: number;\r\n}\r\n\r\nexport interface Station {\r\n    name: string\r\n    id: string,\r\n    tags: string,\r\n    country: string,\r\n    language: string,\r\n    icon: string,\r\n    votes: number,\r\n    // fields below are added to v1\r\n    codec:string,              \r\n    bitrate:number,            \r\n}\r\n\r\n/// station format from api.radio-browser\r\ninterface RadioStation { \r\n    /** A globally unique identifier for the change of the station information */\r\n    changeuuid:string,         \r\n    /**A globally unique identifier for the station */\r\n    stationuuid:string,        \r\n    /**  The name of the station */\r\n    name:string, \t           \r\n    /**  URL (HTTP/HTTPS) \tThe stream URL provided by the user*/\r\n    url:string,                \r\n    /** URL (HTTP/HTTPS) \tAn automatically \"resolved\" stream URL. Things resolved are playlists (M3U/PLS/ASX...), HTTP redirects (Code 301/302). This link is especially usefull if you use this API from a platform that is not able to do a resolve on its own (e.g. JavaScript in browser) or you just don't want to invest the time in decoding playlists yourself. */\r\n    url_resolved:string,       \r\n    /** URL (HTTP/HTTPS) \tURL to the homepage of the stream, so you can direct the user to a page with more information about the stream. */\r\n    homepage:string,           \r\n    /**  URL (HTTP/HTTPS) \tURL to an icon or picture that represents the stream. (PNG, JPG)*/\r\n    favicon:string,            \r\n    /** multivalue, split by comma \tTags of the stream with more information about it */\r\n    tags:string,               \r\n    /** DEPRECATED: use countrycode instead, full name of the country */ \r\n    country:string             \r\n    /** 2 letters, uppercase \tOfficial countrycodes as in ISO 3166-1 alpha-2 */\r\n    countrycode:string,        \r\n    /**  Full name of the entity where the station is located inside the country*/\r\n    state:string,              \r\n    /** multivalue, split by comma \tLanguages that are spoken in this stream. */\r\n    language:string,           \r\n    /** integer \tNumber of votes for this station. This number is by server and only ever increases. It will never be reset to 0. */\r\n    votes:number,              \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tLast time when the stream information was changed in the database */\r\n    lastchangetime:string,     \r\n    /** The codec of this stream recorded at the last check. */\r\n    codec:string,              \r\n    /** integer, bps \tThe bitrate of this stream recorded at the last check. */\r\n    bitrate:number,            \r\n    /** 0 or 1 \tMark if this stream is using HLS distribution or non-HLS. */\r\n    hls:number,                \r\n    /** 0 or 1 \tThe current online/offline state of this stream. This is a value calculated from multiple measure points in the internet. \r\n     * The test servers are located in different countries. It is a majority vote. */\r\n    lastcheckok: number        \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when any radio-browser server checked the online state of this stream */\r\n    lastchecktime:string,      \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when the stream was checked for the online status with a positive result */\r\n    lastcheckoktime:string,    \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when this server checked the online state and the metadata of this stream */\r\n    lastlocalchecktime:string, \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe time of the last click recorded for this stream */\r\n    clicktimestamp:string,     \r\n    /** integer \tClicks within the last 24 hours */\r\n    clickcount:number,         \r\n    /** integer \tThe difference of the clickcounts within the last 2 days. Posivite values mean an increase, negative a decrease of clicks. */\r\n    clicktrend:number,         \r\n}\r\n\r\nfunction toStation(r:RadioStation):Station {\r\n    return {  name: r.name,\r\n              id: r.stationuuid,\r\n              tags: r.tags,\r\n              country: r.country,\r\n              language: r.language,\r\n              icon: r.favicon,\r\n              votes: r.votes,\r\n              codec: r.codec,\r\n              bitrate: r.bitrate\r\n    }\r\n}\r\n\r\n// api docs at: https://api.radio-browser.info/\r\n// and https://de1.api.radio-browser.info/#Advanced_station_search\r\nexport class RadioSearch {\r\n    public query: Query\r\n    private offset = 0\r\n    private _hasMoreResults = false\r\n\r\n    results:Station[] = []\r\n    constructor(query: Query) {\r\n        this.query = query\r\n        if (this.query.limit == undefined)\r\n            this.query.limit = 20\r\n    }\r\n\r\n    /// @return with the number of stations found\r\n    async search() {\r\n        // compute url\r\n        let url = `${apiUrl}/stations/search?name=${this.query.name}&order=votes&reverse=true&limit=${this.query.limit}&offset=${this.offset}`\r\n        // do the stuff\r\n        let results = await fetch(url).then(res => res.json())\r\n        let res:Station[] = results.map(toStation)\r\n        this.results.push(...res)\r\n        this.offset = this.results.length\r\n        this._hasMoreResults = res.length == this.query.limit // when fever results are returned, then no more results are available\r\n    }\r\n\r\n    get hasMoreResults() { return this._hasMoreResults }\r\n}\r\n\r\nexport async function getStreamUrl(station:Station) {\r\n    var url = `${apiUrl}/url/${station.id}`;\r\n    var res = await fetch(url).then(res=>res.json())\r\n    if (res && res.url)\r\n        return res.url as string;\r\n    else return undefined;\r\n}\r\n\r\nexport async function refreshStation(station:Station) {\r\n    var url = `${apiUrl}/stations/byuuid/${station.id}` // get info for this station only\r\n    var res = await fetch(url).then(res=>res.json())\r\n    // will return an array with one item\r\n    if (res && res[0]) {\r\n        return toStation(res[0])\r\n    }\r\n}\r\n\r\nexport async function voteForStation(station:Station) {\r\n    var url = `${apiUrl}/vote/${station.id}`; \r\n    // will return status of vote (in the ok field)\r\n    try {\r\n        var res = await fetch(url)\r\n        if (res.ok) {\r\n            res = await res.json()\r\n            return res.ok\r\n        } else return false\r\n    } catch (err) {\r\n        return false\r\n    }\r\n}\r\n\r\nconst apiUrl = \"https://de1.api.radio-browser.info/json\" // todo: should do dns lookup as the docs ask\r\n\r\nexport function needsUpgrade(station:Station) {\r\n    // from v0 to v1 (codec and bitrate added)\r\n    return station.codec == undefined || station.bitrate == undefined;\r\n}\r\n\r\nexport async function upgradeStation(station:Station) {\r\n    let refreshed = await refreshStation(station)\r\n    if (refreshed) {\r\n        station.codec = refreshed.codec;\r\n        station.bitrate = refreshed.bitrate;\r\n        // could refresh all fields but only these have been added\r\n        return true\r\n    }\r\n    return false\r\n}","import { Station, needsUpgrade, upgradeStation } from \"./radioApi\";\r\n\r\nexport async function getLastPlayedStation():Promise<Station | undefined> {\r\n    const stat = localStorage.getItem(\"lastPlayed\")\r\n    if (stat) {\r\n        let station:Station = JSON.parse(stat)\r\n        if (needsUpgrade(station))\r\n            await upgradeStation(station)\r\n        return station\r\n    }\r\n}\r\n\r\nexport function saveLastPlayedStation(station:Station) {\r\n    localStorage.setItem(\"lastPlayed\", JSON.stringify(station))\r\n}","export interface Subscription {\r\n    unsubscribe():void\r\n}\r\n\r\nexport interface Subscriber<T> {\r\n    onChange(newVal:T):void\r\n}\r\n\r\nexport class SubscriptionRepository {\r\n    // todo: add a generic getter function for the given properties, using T type\r\n    //       this will ensure users with correct types, and they don't have to type strings\r\n    // ex.: getSubscription<MyuSuperType>(\"alma\")\r\n    //      user codes could write: {  get onAlma() { return  this.subs.getSubscription<AlmaType>() } }\r\n\r\n    add(name:string, changeFunc:(newVal:any) => void):Subscription {\r\n        let subsForName = this.subs.get(name) || []\r\n        if (subsForName.length == 0) {\r\n            this.subs.set(name, subsForName)\r\n        }\r\n\r\n        let sub = { onChange: changeFunc }\r\n        subsForName.push(sub)\r\n        return {\r\n            unsubscribe: () => {\r\n                const idx = subsForName.findIndex(val => val == sub)\r\n                if (idx >= 0) subsForName.splice(idx)\r\n            }\r\n        }\r\n    }\r\n\r\n    notifyFor(name:string, newVal:any) {\r\n        let subsForName = this.subs.get(name)\r\n        if (subsForName)\r\n            for (let s of subsForName) s.onChange(newVal)\r\n    }\r\n\r\n    private subs = new Map<string, Subscriber<any>[]>()\r\n}\r\n\r\n","import { Howl } from \"howler\"\r\nimport { Station, getStreamUrl } from \"./radioApi\"\r\nimport { saveLastPlayedStation } from \"./lastPlayed\"\r\nimport { SubscriptionRepository } from \"../models/base\"\r\n\r\nexport type StatusCallback = (status:string, detail?:string)=>any\r\n\r\nexport class LoadError extends Error{\r\n    constructor(message:string) {\r\n        super(message)\r\n        this.name = \"LoadError\"\r\n    }\r\n}\r\n\r\nexport default class RadioPlayer {\r\n    player:Howl|undefined\r\n    station:Station|undefined\r\n    private statusEmitter:StatusCallback[] = [] // todo: replace usage with subs repo\r\n    private subs = new SubscriptionRepository()\r\n    private loading:Promise<void>|undefined\r\n\r\n    async setStation(station:Station) {\r\n        // stop old player\r\n        if (this.player) {\r\n            this.player.off() // remove old events, and stop\r\n            this.player.stop()\r\n            this.player.unload()\r\n            this.player = undefined\r\n        }\r\n        // todo: use subscription repository and notify about station change in the player\r\n        //       status change also should be fired through subs repo\r\n        this.fireStatusChange(\"load\", \"station\")\r\n        this.station = station\r\n        this.subs.notifyFor(\"station\", station)\r\n        \r\n        saveLastPlayedStation(station)\r\n        // will save loading promise, as users may use play while station url is loading\r\n        // in these cases play should progress as well (see play)\r\n        this.loading = this.loadPlayer(station)\r\n        return this.loading\r\n    }\r\n\r\n    private async loadPlayer(station:Station) {\r\n        // get station url ...\r\n        let url = await getStreamUrl(station)\r\n        this.loading = undefined\r\n        if (!url) {\r\n            this.fireStatusChange(\"error\", \"cannot resolve station url\")\r\n            throw new LoadError(\"Cannot resolve station url\")\r\n        } \r\n        if (this.station?.id == station.id) { // haven't changed stations meanwhile\r\n            if (this.player) {\r\n                this.player.off()\r\n                this.player.unload() // if somehow an old player gets stuck, unload it\r\n            }\r\n            this.player = new Howl({src: url, autoplay: false, html5: true, preload: false})\r\n            this.fireStatusChange(\"stop\")\r\n            this.player.on('load', ()=> this.fireStatusChange(\"load\", \"start playing\"))\r\n            this.player.on('play', ()=> this.fireStatusChange(\"play\") )\r\n            this.player.on('stop', ()=> this.fireStatusChange(\"stop\") )\r\n            this.player.on('pause', ()=> this.fireStatusChange(\"stop\") )\r\n\r\n            // NOTE: howl will fire load errors for radio streams, without extension, if you call the `load()` method\r\n            //       this is probably a bug? (as play will report no errors)\r\n            const formatError = (error) => {\r\n                if (typeof error == \"number\")\r\n                    return `Error code: ${error}`\r\n                else return `Details: ${error}`\r\n            }\r\n            this.player.on('loaderror', (_, error)=> this.fireStatusChange(\"error\", \"Loading the stream failed!\\n\" + formatError(error)))\r\n            this.player.on('playerror', (_, error)=> this.fireStatusChange(\"error\", \"Playback error!\\n\" + formatError(error)))\r\n        } else {\r\n            throw new LoadError(\"Changed stations while loading\")\r\n        }\r\n    }\r\n\r\n    async play() {\r\n        if (!this.player && this.station) {\r\n            await this.loadPlayer(this.station)\r\n        }\r\n        try {\r\n            if (this.loading)\r\n                await this.loading\r\n        } catch (err) {\r\n            if (err instanceof LoadError)\r\n                return; // can't play this stream\r\n            else throw err // rethrow other errors\r\n        }\r\n        \r\n        if (this.player && !this.player.playing()) {\r\n            // when not loaded\r\n            if (this.player.state() == \"unloaded\") {\r\n                this.fireStatusChange(\"load\", \"stream\")\r\n                // no need to use `load`, see the loadError remark. play will load the stream\r\n            }\r\n            this.player.volume(this._volume / 100)\r\n            this.player.play()\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if (this.player) {\r\n            this.player.off() // remove old events, and stop\r\n            this.player.stop()\r\n            this.player.unload() // preserve battery\r\n            this.fireStatusChange(\"stop\") // sometimes howl doesn't notify :( about stop\r\n            this.player = undefined\r\n        }\r\n    }\r\n\r\n    private _volume:number = 100\r\n    // set the volume in 0 to 100 range\r\n    set volume(vol:number) {\r\n        this._volume = vol\r\n        if (this.player) {\r\n            this.player.volume(vol / 100) // howler works with 0 and 1 range\r\n        }\r\n    }\r\n\r\n    private fireStatusChange(newStatus:string, detail?:string) {\r\n        for (let cb of this.statusEmitter) {\r\n            cb(newStatus, detail)\r\n        }\r\n    }\r\n\r\n    onStatusChanged(cb: StatusCallback) {\r\n        this.statusEmitter.push(cb)\r\n        return cb\r\n    }\r\n\r\n    offStatusChanged(cb:StatusCallback) {\r\n        const idx = this.statusEmitter.findIndex(val => cb == val)\r\n        if (idx >= 0)\r\n            this.statusEmitter.splice(idx, 1)\r\n    }\r\n\r\n    subscribe(prop: \"station\", changeFn:(newVal:any) => void) {\r\n        return this.subs.add(prop, changeFn)\r\n    }\r\n}","import { Station, needsUpgrade, upgradeStation } from \"./radioApi\";\r\n\r\nexport type UpdateCallback = () => any\r\n\r\n// uses localStorage to keep a list of favorite stations\r\nclass Favorites {\r\n    private stations:Station[] = []\r\n    \r\n    add(station:Station) {\r\n        if (!this.isFavorite(station)) {\r\n            this.stations.push(station)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    remove(station:Station) {\r\n        const idx = this.stations.findIndex(val => val.id == station.id)\r\n        if (idx >= 0) {\r\n            this.stations.splice(idx, 1)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    isFavorite(station:Station):boolean {\r\n        const stat = this.stations.find(val => val.id == station.id)\r\n        return stat != undefined\r\n    }\r\n\r\n    get list() {\r\n        return this.stations\r\n    }\r\n\r\n    private save() { // save to local storage\r\n        localStorage.setItem(\"stations\", JSON.stringify(this.stations))\r\n        this.changed()\r\n    }\r\n\r\n    async load() { // load from local storage\r\n        let stats = localStorage.getItem(\"stations\")\r\n        if (stats) {\r\n            let stations:Station[] = JSON.parse(stats)\r\n            // check for upgrades\r\n            let upgrades:Promise<boolean>[] = []\r\n            for (let station of stations) {\r\n                if (needsUpgrade(station)) {\r\n                    upgrades.push(upgradeStation(station))\r\n                }\r\n            }\r\n            try {\r\n                if (upgrades.length) {\r\n                    await Promise.all(upgrades)\r\n                    this.stations = stations\r\n                    this.save() // save upgraded stations, so next time they don't have to be upgraded\r\n                }\r\n            } finally {\r\n                if (this.stations != stations) {\r\n                    this.stations = stations\r\n                    this.changed()\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateCbs:UpdateCallback[] = []\r\n    onUpdated(ucb:UpdateCallback):UpdateCallback {\r\n        this.updateCbs.push(ucb)\r\n        return ucb\r\n    }\r\n\r\n    private changed() {\r\n        for (const cb of this.updateCbs)\r\n            cb()\r\n    }\r\n}\r\n\r\nexport const favorites = new Favorites()","import React from \"react\"\r\nimport { RangeModel } from \"../models/range\"\r\nimport { Subscription } from \"../models/base\"\r\n\r\ninterface SliderProps {\r\n    model:RangeModel\r\n}\r\n\r\nexport class Slider extends React.Component<SliderProps> {\r\n    get model() { return this.props.model }\r\n    private valueChangeSub:Subscription|undefined\r\n\r\n    componentDidMount() {\r\n        this.valueChangeSub = this.model.subscribe(\"value\", () => {\r\n            this.updateSliderStyles() // update thumb and progress pos\r\n        })\r\n        \r\n        this.setState({}) // trigger a refresh, so refs get sizes\r\n        if (this.thumb.current) {\r\n            this.thumb.current.setAttribute(\"touch-action\",  \"none\") // in order for the pointerEvent polyfill to work\r\n        }\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        this.updateSliderStyles() // style refresh\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.valueChangeSub) this.valueChangeSub.unsubscribe()\r\n    }\r\n\r\n    private updateSliderStyles() {\r\n        if (this.sliderBg.current && this.thumb.current) {\r\n            let model = this.model;\r\n            const trackSize = this.sliderBg.current.clientWidth - this.thumb.current.clientWidth\r\n            const thumbWidth = this.thumb.current.clientWidth\r\n            let pos = (model.val - model.min) * trackSize / (model.max - model.min) // left pos on track\r\n            let posCross = -(this.thumb.current.clientHeight - this.sliderBg.current.clientHeight) / 2;\r\n            this.thumb.current.setAttribute(\"style\", `left: ${pos}px; top:${posCross}px`)\r\n            if (this.sliderProgress.current) {\r\n                this.sliderProgress.current.setAttribute(\"style\", `width: ${pos + thumbWidth / 2}px`)\r\n            }\r\n        }\r\n    }\r\n\r\n    private posStartDrag = 0\r\n    private valStart = 0\r\n    private sliderBg = React.createRef<HTMLDivElement>()\r\n    private thumb = React.createRef<HTMLSpanElement>()\r\n    private sliderProgress = React.createRef<HTMLDivElement>()\r\n    private dragging = false\r\n\r\n    onPointerMove(e:MouseEvent) {\r\n        if (this.dragging && this.sliderBg.current && this.thumb.current) {\r\n            \r\n            const trackSize = this.sliderBg.current.clientWidth - this.thumb.current.clientWidth // corresponds to change in range max - min\r\n            let offs = e.clientX - this.posStartDrag\r\n            if (trackSize > 0) {\r\n                let change = offs * (this.model.max - this.model.min) / trackSize\r\n                this.model.val = this.valStart + change // this will update the display automatically\r\n            }\r\n        }\r\n    }\r\n\r\n    moveListener = (e:MouseEvent) => this.onPointerMove(e)\r\n    upListener = (e:MouseEvent) => this.onPointerUp(e)\r\n\r\n    onPointerDown(e:React.MouseEvent) {\r\n        // todo: check button/finger here\r\n        this.posStartDrag = e.clientX\r\n        this.valStart = this.model.val;\r\n        this.dragging = true\r\n        window.addEventListener(\"pointermove\", this.moveListener)\r\n        window.addEventListener(\"pointerup\", this.upListener)\r\n    }\r\n\r\n    onPointerUp(e:MouseEvent) {\r\n        this.dragging = false\r\n        window.removeEventListener(\"mousemove\", this.moveListener)\r\n        window.removeEventListener(\"mouseup\", this.upListener)\r\n    }\r\n\r\n    render() {\r\n        return <div className=\"slider bg\" ref={this.sliderBg}>\r\n                    <div className=\"slider progress\" ref={this.sliderProgress}></div>\r\n                    <span className=\"thumb\" ref={this.thumb} \r\n                          onPointerDown={e=>this.onPointerDown(e)}>\r\n                        {this.props.children}\r\n                    </span>\r\n               </div>\r\n    }\r\n}","import { Subscription, SubscriptionRepository } from \"./base\"\r\n\r\n// model reperesenting range and value \r\nexport class RangeModel { \r\n    private _min:number = 0\r\n    private _max:number = 100\r\n    private _val:number = 0\r\n    \r\n    get val():number { return this._val }\r\n    get min():number { return this._min }\r\n    get max():number { return this._max }\r\n\r\n    set val(newVal:number) {\r\n        if (newVal < this._min) newVal = this._min\r\n        else if (newVal > this._max) newVal = this._max\r\n        this.updateValue(newVal)\r\n    }\r\n\r\n    /// replace range, if min or max is not given the old values are used\r\n    setRange(min:number|undefined, max:number|undefined) {\r\n        if (min == undefined) min = this._min\r\n        if (max == undefined) max = this._max\r\n        if (min >= max) \r\n            throw new Error(`Invalid range! (min < max) should hold. Got: ${min} >= ${max}`)\r\n        this._min = min\r\n        this._max = max\r\n        if (this._val < min)\r\n            this.updateValue(min)\r\n        else if (this._val > max)\r\n            this.updateValue(max)\r\n    }\r\n\r\n    // subscribe for changes in value\r\n    subscribe(prop:\"value\", changeFunc:(v:number) => void):Subscription {\r\n        return this.subs.add(prop, changeFunc)\r\n    }\r\n\r\n    private updateValue(newVal:number) {\r\n        if (this._val != newVal) {\r\n            this._val = newVal\r\n            this.subs.notifyFor(\"value\", newVal)\r\n        }\r\n    }\r\n\r\n    private subs = new SubscriptionRepository()\r\n}\r\n","import React from \"react\"\r\nimport { Station, voteForStation, refreshStation } from \"../functions/radioApi\"\r\nimport RadioPlayer, {StatusCallback, LoadError} from \"../functions/radioPlayer\"\r\nimport { favorites } from \"../functions/favorites\"\r\nimport { Slider } from \"./slider\"\r\nimport { RangeModel } from \"../models/range\"\r\n\r\nexport let radioPlayer = new RadioPlayer()\r\n\r\ninterface PlayerProps {\r\n    station:Station|undefined\r\n    className:string\r\n}\r\n\r\ninterface PlayerState {\r\n    status: string\r\n    detail?: string \r\n    voting: boolean\r\n    displayError:boolean // when set, error info box should be displayed, instead of play control button\r\n}\r\n\r\nexport default class Player extends React.Component<PlayerProps, PlayerState> {\r\n    state:PlayerState = {\r\n        status : \"stop\",\r\n        voting: false,\r\n        displayError: false\r\n    }\r\n\r\n    private statusChangeId:StatusCallback|undefined\r\n    private volume = new RangeModel()\r\n    componentDidMount() {\r\n        this.statusChangeId = radioPlayer.onStatusChanged((status, detail) => {\r\n            if (radioPlayer.station && this.props.station?.id == radioPlayer.station.id) // only change state, if we display details for the station playing\r\n                this.setState({\r\n                    status,\r\n                    detail,\r\n                    displayError: status == \"error\"\r\n                })\r\n        });\r\n\r\n        this.volume.val = 75; // // todo: should use persisted value and set to radio player\r\n        this.volume.subscribe(\"value\", vol => radioPlayer.volume = vol)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.statusChangeId)\r\n            radioPlayer.offStatusChanged(this.statusChangeId)\r\n    }\r\n\r\n    async togglePlayback() {\r\n        if (!this.props.station)\r\n            return\r\n        const stat = this.getPlayStatus()\r\n        if (stat == \"stop\" || stat == \"error\") {\r\n            if (stat == \"error\")\r\n                radioPlayer.stop() // stop it first\r\n            try {\r\n                this.setState({status:\"load\", detail: undefined})\r\n                if (radioPlayer.station?.id != this.props.station.id)\r\n                    await radioPlayer.setStation(this.props.station)\r\n                radioPlayer.play()\r\n            } catch (loadErr) {\r\n                if (!(loadErr instanceof LoadError)) // no playback when loading fails. status change takes care of notifying the user\r\n                    throw loadErr\r\n            }\r\n        } else {\r\n            radioPlayer.stop()\r\n        }\r\n    }\r\n\r\n    getPlayStatus() {\r\n        let status = this.state.status // this can contain the last status updated by the player\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) {\r\n            status = \"stop\" // this stream hasn't been started\r\n        }\r\n        return status\r\n    }\r\n\r\n    getPlayDetail() {\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) \r\n            return undefined\r\n        else return this.state.detail\r\n    }\r\n\r\n    toggleFavorite() {\r\n        const station = this.props.station;\r\n        if (station) {\r\n            if (favorites.isFavorite(station)) favorites.remove(station)\r\n            else favorites.add(station)\r\n            this.setState({}) // needs update\r\n        }\r\n    }\r\n\r\n    async vote() {\r\n        if (!this.props.station) return\r\n        this.setState({voting: true})\r\n        const succ = await voteForStation(this.props.station)\r\n        \r\n        const refreshed = await refreshStation(this.props.station)\r\n        if (refreshed) {\r\n            this.props.station.votes = refreshed.votes\r\n        }\r\n        \r\n        this.setState({voting: false}) \r\n    }\r\n\r\n    render() {\r\n        const station = this.props.station;\r\n        if (!station) return null\r\n        let status = this.getPlayStatus()\r\n        \r\n        const iconsForStatus = {\r\n            play: \"stop.svg\",\r\n            stop: \"play.svg\",\r\n            load: \"loading.svg\",\r\n            error: \"play.svg\"\r\n        }\r\n\r\n        const buttonIcon =  `/webradio/icons/${iconsForStatus[status]}`;  \r\n        const detail = this.getPlayDetail()\r\n\r\n        const isFavorite = favorites.isFavorite(station)\r\n        const favoriteHeader = isFavorite\r\n                                    ? (<span>\r\n                                          <img className=\"small-ico like\" src=\"/webradio/icons/like.svg\"></img>\r\n                                          Favorite\r\n                                       </span>\r\n                                      )\r\n                                    : undefined;\r\n        const playButton = <button className=\"play\" onClick={e => this.togglePlayback()} >\r\n                              <img className={`play-ico ${status}`} src={buttonIcon}></img>\r\n                           </button>\r\n        \r\n        const errorBox = <div className=\"error-popup flexible horizontal\" onClick={()=> this.setState({displayError: false})} >\r\n                              <img src=\"/webradio/icons/info.svg\"></img>\r\n                              <span className=\"flex1\">{detail}</span>\r\n                              <img src=\"/webradio/icons/close.svg\"></img>\r\n                         </div>\r\n\r\n        return <div className={this.props.className + \" flexible vertical player\"}>\r\n                    <div className=\"player-header flexible horizontal\">\r\n                        <span>{station.country}</span>\r\n                        <span>\r\n                            <img className=\"small-ico\" src=\"/webradio/icons/votes.svg\"></img>\r\n                            {station.votes}\r\n                        </span>\r\n                        {favoriteHeader}\r\n                    </div>\r\n                    <h2 className=\"title\">{station.name}</h2>\r\n                    <p className=\"tags\">{station.tags}</p>\r\n                    <button className=\"favorite-toggle\" onClick={()=> this.toggleFavorite()} >\r\n                        <img className=\"small-ico like\" src={isFavorite ? \"/webradio/icons/unlike.svg\" : \"/webradio/icons/like.svg\"}></img>\r\n                        <span className=\"text\">{isFavorite ? \"Remove Favorite\" : \"Add as Favorite\"}</span>\r\n                    </button>\r\n                    <div className={`play-area  ${this.state.displayError ? \"error\" : \"\"}`}>\r\n                        {this.state.displayError ? errorBox : playButton}\r\n                    </div>\r\n                    <div className=\"flexible horizontal play-footer\">\r\n                        <span className=\"flex1\">{station.codec} - {station.bitrate} kbps</span>\r\n                        <button className=\"vote\" onClick={()=> this.vote() }disabled={this.state.voting} >\r\n                            <img className=\"small-ico\" src=\"/webradio/icons/votes.svg\"></img>\r\n                            Vote\r\n                        </button> \r\n                    </div>\r\n                    \r\n                    <Slider model={this.volume} >\r\n                        <img className=\"volume\" src=\"/webradio/icons/volume.svg\" draggable=\"false\"></img>\r\n                    </Slider>\r\n               </div>\r\n    }\r\n}","import React from 'react'\r\n\r\nexport default class About extends React.Component<{className:string}> {\r\n    render() {\r\n        return <div className={\"about \" + this.props.className} >\r\n            <h2>About webradio</h2>\r\n            <p>\r\n                Open source webradio implementation using React. \r\n            </p>\r\n            <p>\r\n                Uses the api provided by <a target=\"blank\" href=\"http://www.radio-browser.info\">www.radio-browser.info</a>\r\n            </p>\r\n            <p>\r\n                If you find any issues, or have feature requests please report them at the project's github page: <a href=\"https://github.com/bxantus/webradio\" target=\"blank\">github.com/bxantus/webradio</a>\r\n            </p>\r\n            <a href=\"https://bxantus.github.io/webradio/index.html\">\r\n                <img className=\"qr-code\" src=\"/webradio/address_qr.png\"></img>\r\n            </a>\r\n            <h4>Link for mobile devices:</h4>\r\n            <p className=\"small-margin\">\r\n                Scan the code to the right on a mobile phone to open webradio on it!\r\n            </p>\r\n        </div>\r\n    }\r\n}","import React from 'react';\r\nimport RadioSearch from './components/search'\r\nimport RadioPlayerUI, { radioPlayer } from './components/player'\r\nimport { Station } from './functions/radioApi';\r\nimport About from './components/about';\r\nimport StationList from './components/stationList';\r\nimport { favorites } from './functions/favorites';\r\nimport { getLastPlayedStation } from './functions/lastPlayed';\r\nimport SearchModel from './functions/searchModel'\r\n\r\ninterface RadioState {\r\n    selectedTab:Tab\r\n    selectedStation?:Station\r\n}\r\n\r\ninterface Tab {\r\n    title: string\r\n    content: (cls:string) => JSX.Element\r\n    scrollOffset?:number\r\n}\r\n\r\nlet currentSearch= new SearchModel\r\n\r\nexport default class WebradioApp extends React.Component<{}, RadioState> {\r\n    state:RadioState \r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            selectedTab: this.searchTab, // todo: by default we could start with the about (help) tab\r\n        }\r\n        favorites.load();\r\n    }\r\n\r\n    async componentDidMount() {\r\n        favorites.onUpdated(() => {\r\n            this.setState({}) // update\r\n        })\r\n        radioPlayer.subscribe(\"station\", (station:Station) => {\r\n            this.setState({}) // update display of currently playing station\r\n        })\r\n        const lastPlayed = await getLastPlayedStation()\r\n        if (lastPlayed) {\r\n            radioPlayer.setStation(lastPlayed)\r\n            this.stationSelected(lastPlayed) // switch to play tab\r\n        }\r\n    }\r\n\r\n    tabs = [\r\n        { title: \"Favorites\", content: (cls:string) => <div className={cls}><StationList stations={favorites.list} onStationSelected={station=> this.stationSelected(station)} ></StationList></div> },\r\n        { title: \"Playing\", content: (cls:string) => <RadioPlayerUI className={cls} station={this.state.selectedStation}></RadioPlayerUI> },\r\n        { title: \"About\", content: (cls:string) => <About className={cls} ></About>},\r\n    ]\r\n    \r\n\r\n    private searchTab:Tab = { \r\n                              title: \"Search\", \r\n                              content: (cls:string) => <RadioSearch className={cls} search={currentSearch} onStationSelected={station=> this.stationSelected(station)}>Search content</RadioSearch>,\r\n                              scrollOffset: 0\r\n                            }\r\n\r\n\r\n    changeTab(tab:Tab, userSelect=true)  {\r\n        this.state.selectedTab.scrollOffset = document.scrollingElement?.scrollTop ?? 0 // save scroll offset\r\n        this.setState({\r\n            selectedTab: tab\r\n        })\r\n        if (userSelect) {\r\n            this.setState({\r\n                selectedStation: radioPlayer.station\r\n            })\r\n        }\r\n    }\r\n\r\n    stationSelected(station:Station) {\r\n        this.setState({\r\n            selectedStation: station\r\n        })\r\n        // todo: should use rather tab id\r\n        this.changeTab(this.tabs[1], /*userSelect*/false)  \r\n    }\r\n\r\n    searchTextChanged(e) {\r\n        const query = e.target.value;\r\n        currentSearch.scheduleSearch(query)\r\n    }\r\n\r\n    private searchInput = React.createRef<HTMLInputElement>()\r\n    private focusOnSearch = false\r\n    selectSearch() {\r\n        this.changeTab(this.searchTab)\r\n        this.focusOnSearch = true\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        if (this.focusOnSearch && this.searchInput.current) {\r\n            this.searchInput.current.focus()\r\n            this.focusOnSearch = false\r\n        }\r\n        if (document.scrollingElement) {\r\n            if (this.state.selectedTab == this.searchTab) {\r\n                document.scrollingElement.scrollTop = this.searchTab.scrollOffset ?? 0 // preserve search scroll\r\n            } else document.scrollingElement.scrollTop = 0 // on other views reset scroll\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const tabs = this.tabs\r\n        const selectedTab = this.state.selectedTab\r\n        \r\n        const tabTitles = tabs.map(tab => {\r\n                    let selection = (selectedTab == tab) ? <span className=\"selection\"></span> : undefined\r\n                    return <div className=\"tab flexible vertical\"\r\n                               key={tab.title} onClick={e=>this.changeTab(tab)} >\r\n                                    <span className=\"title\">{tab.title}</span>\r\n                                    {selection}\r\n                           </div> \r\n        })\r\n        const allTabs = [this.searchTab].concat(tabs)\r\n        const tabContent = allTabs.map(tab => tab.content(tab == selectedTab ? \"visible\" : \"hidden\"))\r\n        const searchSelected = this.searchTab == selectedTab;\r\n        \r\n        return (\r\n            <div className=\"radio-App\">\r\n                <div id=\"top\" className=\"flexible vertical radio\">\r\n                    <div className=\"header flexible horizontal\">\r\n                        <img className=\"logo\" src=\"/webradio/logo.svg\"></img>\r\n                        <span className={`divider ${searchSelected ? \"blinking\" : \"static\"}`}></span>\r\n                        <span className={`currently-playing ${searchSelected ? \"hidden\" : \"visible\"}`}>\r\n                            {radioPlayer.station?.name}\r\n                        </span>\r\n                        <input className={`search flex1 ${searchSelected ? \"visible\" : \"hidden\"}`} \r\n                            ref={this.searchInput}\r\n                            defaultValue={currentSearch.searchText} \r\n                            onInput={ (e) => { this.searchTextChanged(e) } }>\r\n                        </input>\r\n                    </div>\r\n                    <div className=\"tabs flexible horizontal\">\r\n                        <span className=\"flex1\"></span>\r\n                        {tabTitles}\r\n                        <span className=\"flex1\"></span>\r\n                        <a className=\"search-tab\" onClick={e=> this.selectSearch()}>\r\n                            <img className=\"icon search\" src=\"/webradio/icons/search.svg\"></img>\r\n                        </a>\r\n                    </div>\r\n                </div>\r\n                <div id=\"content\" className=\"radio flexible vertical\">\r\n                    {tabContent}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import { RadioSearch } from \"./radioApi\";\r\nimport { SubscriptionRepository, Subscription } from \"../models/base\";\r\n\r\n\r\nexport default class Search  {\r\n    private subs = new SubscriptionRepository()\r\n    private searchTimer\r\n    private currentSearch:RadioSearch|undefined\r\n\r\n    get searchText() {\r\n        return this.currentSearch ? this.currentSearch.query.name : \"\"\r\n    }\r\n\r\n    async scheduleSearch(query:string, timeout = 400) {\r\n        this.searchTimer = clearTimeout(this.searchTimer)\r\n        this.searchTimer = setTimeout(async () => {\r\n            let search = new RadioSearch({name: query})\r\n            this.currentSearch = search\r\n            this.subs.notifyFor(\"searching\", true)\r\n            await search.search()\r\n            this.subs.notifyFor(\"query\", undefined) // search query changed\r\n            this.subs.notifyFor(\"searching\", false)\r\n            this.subs.notifyFor(\"results\", search.results)\r\n        }, timeout)\r\n    }\r\n\r\n    async loadMoreResults() {\r\n        if (this.currentSearch && this.currentSearch.hasMoreResults) {\r\n            this.subs.notifyFor(\"searching\", true)\r\n            await this.currentSearch.search()\r\n            this.subs.notifyFor(\"searching\", false)\r\n            this.subs.notifyFor(\"results\", this.currentSearch.results)\r\n        }\r\n    }\r\n\r\n    subscribe(prop: \"searching\" | \"results\" | \"query\", changeFunc:(newVal:any) => void):Subscription {\r\n        return this.subs.add(prop, changeFunc)\r\n    }\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport WebRadio from './webradio'\n\nReactDOM.render(\n  <React.StrictMode>\n    <WebRadio>my text</WebRadio>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}