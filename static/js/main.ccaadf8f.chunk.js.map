{"version":3,"sources":["functions/radioSearch.ts","components/search.tsx","components/stationList.tsx","functions/lastPlayed.ts","functions/radioPlayer.ts","functions/favorites.ts","components/player.tsx","components/about.tsx","webradio.tsx","index.tsx"],"names":["RadioSearch","query","offset","results","this","undefined","limit","url","apiUrl","name","fetch","then","res","json","map","r","id","stationuuid","tags","country","language","icon","favicon","votes","push","getStreamUrl","station","a","ok","currentSearch","StationList","stations","props","className","onClick","onStationSelected","key","React","Component","Search","searchTimer","searchList","state","search","searching","createRef","e","target","value","scheduleSearch","clearTimeout","setTimeout","setState","current","scrollTop","radioSearch","defaultValue","onInput","searchTextChanged","ref","saveLastPlayedStation","localStorage","setItem","JSON","stringify","LoadError","message","Error","RadioPlayer","player","statusEmitter","loading","off","stop","unload","fireStatusChange","loadPlayer","Howl","src","autoplay","html5","preload","on","_","error","playing","play","newStatus","detail","cb","idx","findIndex","val","splice","favorites","updateCbs","isFavorite","save","find","changed","stats","getItem","parse","ucb","radioPlayer","Player","status","statusChangeId","onStatusChanged","offStatusChanged","getPlayStatus","setStation","remove","add","detailText","playButtonText","load","getPlayDetail","togglePlayback","toggleFavorite","About","href","WebradioApp","selectedTab","onUpdated","lastPlayed","stat","getLastPlayedStation","stationSelected","tab","userSelect","title","selectedStation","changeTab","tabs","selectedTabName","headerContent","tabElements","content","cls","list","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ccaadf8f.chunk.js","sourcesContent":["\r\nexport interface Query {\r\n    name: string;\r\n    tags?: string;\r\n    limit?: number;\r\n}\r\n\r\nexport interface Station {\r\n    name: string\r\n    id: string,\r\n    tags: string,\r\n    country: string,\r\n    language: string,\r\n    icon: string,\r\n    votes: number,\r\n}\r\n\r\n// api docs at: https://api.radio-browser.info/\r\n// and https://de1.api.radio-browser.info/#Advanced_station_search\r\nexport class RadioSearch {\r\n    public query: Query\r\n    private offset = 0\r\n\r\n    results:Station[] = []\r\n    constructor(query: Query) {\r\n        this.query = query\r\n        if (this.query.limit == undefined)\r\n            this.query.limit = 20\r\n    }\r\n\r\n    async search() {\r\n        // compute url\r\n        let url = `${apiUrl}/stations/search?name=${this.query.name}&order=votes&reverse=true&limit=${this.query.limit}&offset=${this.offset}`\r\n        // do the stuff\r\n        let results = await fetch(url).then(res => res.json())\r\n        let res:Station[] = results.map(r =>({  name: r.name,\r\n                                                id: r.stationuuid,\r\n                                                tags: r.tags,\r\n                                                country: r.country,\r\n                                                language: r.language,\r\n                                                icon: r.favicon,\r\n                                                votes: r.votes,\r\n                                            }))\r\n        this.results.push(...res)\r\n    }\r\n}\r\n\r\nexport async function getStreamUrl(station:Station) {\r\n    var url = `${apiUrl}/url/${station.id}`;\r\n    var res = await fetch(url).then(res=>res.json())\r\n    if (res && res.ok)\r\n        return res.url as string;\r\n    else return undefined;\r\n}\r\n\r\nconst apiUrl = \"https://de1.api.radio-browser.info/json\" // todo: should do dns lookup as the docs ask","import React from 'react';\r\nimport { RadioSearch, Station } from '../functions/radioSearch';\r\nimport StationList from './stationList';\r\n\r\ninterface SearchState {\r\n    search: RadioSearch|undefined\r\n    searching:boolean\r\n}\r\n\r\ninterface SearchProps {\r\n    onStationSelected?:(station:Station)=> any\r\n    className?: string\r\n}\r\n\r\nlet currentSearch:RadioSearch|undefined // only one search active at a time\r\n\r\nexport default class Search extends React.Component<SearchProps, SearchState> {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            search: currentSearch,\r\n            searching: false\r\n        }\r\n        this.searchList = React.createRef<HTMLDivElement>()\r\n    }\r\n\r\n    async searchTextChanged(e) {\r\n        const query = e.target.value;\r\n        this.scheduleSearch(query)\r\n    }\r\n\r\n    private searchTimer\r\n    private searchList:React.RefObject<HTMLDivElement>\r\n\r\n    async scheduleSearch(query:string) {\r\n        this.searchTimer = clearTimeout(this.searchTimer)\r\n        this.searchTimer = setTimeout(async () => {\r\n            let search = new RadioSearch({name: query})\r\n            currentSearch = search\r\n            this.setState({searching: true})\r\n            await search.search()\r\n            // reset scroll\r\n            if (this.searchList.current) this.searchList.current.scrollTop = 0\r\n            this.setState({\r\n                search,\r\n                searching: false\r\n            })\r\n        }, 400)\r\n    }\r\n\r\n    render() {\r\n        const radioSearch = this.state.search; \r\n        let results:Station[]|undefined \r\n        if (radioSearch) {\r\n            results = radioSearch.results\r\n        }\r\n        let searching = this.state.searching ? <span className=\"loading\">Searching...</span> : undefined\r\n        return (\r\n            <div className={\"search flexible vertical \" + (this.props.className ?? \"\")}>\r\n                <div className=\"flexible horizontal\">\r\n                    <input className=\"flex1\" defaultValue={radioSearch ? radioSearch.query.name : \"\"} \r\n                      onInput={ (e) => { this.searchTextChanged(e) } }></input>\r\n                    {searching}\r\n                </div>\r\n                \r\n                <div ref={this.searchList} className=\"results scrollable\">\r\n                    <StationList stations={results} onStationSelected={this.props?.onStationSelected}></StationList>\r\n                </div>\r\n                \r\n            </div>\r\n        )\r\n    }\r\n}","import React from \"react\"\r\nimport { Station } from \"../functions/radioSearch\";\r\n\r\ninterface StationsProps {\r\n    stations?: Station[]\r\n    onStationSelected?: (station:Station) => any\r\n}\r\n\r\nexport default class StationList extends React.Component<StationsProps, {}> {\r\n    render() {\r\n        const stations = this.props.stations;\r\n        if (stations) {\r\n            let results = stations.map(station => \r\n                                               <div className=\"clickable\" onClick={ () => this.props?.onStationSelected?.(station) } key={station.id}>\r\n                                                 <div className=\"flexible horizontal station-header\">\r\n                                                    <h3>{station.name}</h3>\r\n                                                    <span>{station.votes}</span>\r\n                                                 </div>\r\n                                                 <div>{station.tags}</div>\r\n                                                 <div>{station.country}</div>\r\n                                                 <hr></hr>\r\n                                               </div> )\r\n            return results\r\n        } else return null\r\n    }\r\n}","import { Station } from \"./radioSearch\";\r\n\r\nexport function getLastPlayedStation():Station | undefined {\r\n    const stat = localStorage.getItem(\"lastPlayed\")\r\n    if (stat)\r\n        return JSON.parse(stat) as Station\r\n}\r\n\r\nexport function saveLastPlayedStation(station:Station) {\r\n    localStorage.setItem(\"lastPlayed\", JSON.stringify(station))\r\n}","import { Howl } from \"howler\"\r\nimport { Station, getStreamUrl } from \"./radioSearch\"\r\nimport { saveLastPlayedStation } from \"./lastPlayed\"\r\n\r\nexport type StatusCallback = (status:string, detail?:string)=>any\r\n\r\nexport class LoadError extends Error{\r\n    constructor(message:string) {\r\n        super(message)\r\n        this.name = \"LoadError\"\r\n    }\r\n}\r\n\r\nexport default class RadioPlayer {\r\n    player:Howl|undefined\r\n    station:Station|undefined\r\n    private statusEmitter:StatusCallback[] = []\r\n    private loading:Promise<void>|undefined\r\n\r\n    async setStation(station:Station) {\r\n        // stop old player\r\n        if (this.player) {\r\n            this.player.off() // remove old events, and stop\r\n            this.player.stop()\r\n            this.player.unload()\r\n            this.player = undefined\r\n        }\r\n        this.fireStatusChange(\"load\", \"station\")\r\n        this.station = station\r\n        \r\n        saveLastPlayedStation(station)\r\n        // will save loading promise, as users may use play while station url is loading\r\n        // in these cases play should progress as well (see play)\r\n        this.loading = this.loadPlayer(station)\r\n        return this.loading\r\n    }\r\n\r\n    private async loadPlayer(station:Station) {\r\n        // get station url ...\r\n        let url = await getStreamUrl(station)\r\n        this.loading = undefined\r\n        if (!url) {\r\n            this.fireStatusChange(\"error\", \"cannot resolve station url\")\r\n            throw new LoadError(\"cannot resolve station url\")\r\n        } \r\n        if (this.station?.id == station.id) { // haven't changed stations meanwhile\r\n            if (this.player) {\r\n                this.player.off()\r\n                this.player.unload() // if somehow an old player gets stuck, unload it\r\n            }\r\n            this.player = new Howl({src: url, autoplay: false, html5: true, preload: false})\r\n            this.fireStatusChange(\"stop\")\r\n            this.player.on('load', ()=> this.fireStatusChange(\"load\", \"start playing\"))\r\n            this.player.on('play', ()=> this.fireStatusChange(\"play\") )\r\n            this.player.on('stop', ()=> this.fireStatusChange(\"stop\") )\r\n            this.player.on('pause', ()=> this.fireStatusChange(\"stop\") )\r\n\r\n            // NOTE: howl will fire load errors for radio streams, without extension, if you call the `load()` method\r\n            //       this is probably a bug? (as play will report no errors)\r\n            this.player.on('loaderror', (_, error)=> this.fireStatusChange(\"error\", \"loading the stream failed: \" + error))\r\n            this.player.on('playerror', (_, error)=> this.fireStatusChange(\"error\", \"playback error: \" + error))\r\n        } else {\r\n            throw new LoadError(\"changed stations while loading\")\r\n        }\r\n    }\r\n\r\n    async play() {\r\n        try {\r\n            if (this.loading)\r\n                await this.loading\r\n        } catch (err) {\r\n            if (err instanceof LoadError)\r\n                return; // can't play this stream\r\n            else throw err // rethrow other errors\r\n        }\r\n        \r\n        if (this.player && !this.player.playing()) {\r\n            // when not loaded\r\n            if (this.player.state() == \"unloaded\") {\r\n                this.fireStatusChange(\"load\", \"stream\")\r\n                // no need to use `load`, see the loadError remark. play will load the stream\r\n            }\r\n            this.player.play()\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if (this.player) {\r\n            this.player.stop()\r\n            this.player.unload() // preserve battery\r\n        }\r\n    }\r\n\r\n    private fireStatusChange(newStatus:string, detail?:string) {\r\n        for (let cb of this.statusEmitter) {\r\n            cb(newStatus, detail)\r\n        }\r\n    }\r\n\r\n    onStatusChanged(cb: StatusCallback) {\r\n        this.statusEmitter.push(cb)\r\n        return cb\r\n    }\r\n\r\n    offStatusChanged(cb:StatusCallback) {\r\n        const idx = this.statusEmitter.findIndex(val => cb == val)\r\n        if (idx >= 0)\r\n            this.statusEmitter.splice(idx, 1)\r\n    }\r\n}","import { Station } from \"./radioSearch\";\r\n\r\nexport type UpdateCallback = () => any\r\n\r\n// uses localStorage to keep a list of favorite stations\r\nclass Favorites {\r\n    private stations:Station[] = []\r\n    \r\n    add(station:Station) {\r\n        if (!this.isFavorite(station)) {\r\n            this.stations.push(station)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    remove(station:Station) {\r\n        const idx = this.stations.findIndex(val => val.id == station.id)\r\n        if (idx >= 0) {\r\n            this.stations.splice(idx, 1)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    isFavorite(station:Station):boolean {\r\n        const stat = this.stations.find(val => val.id == station.id)\r\n        return stat != undefined\r\n    }\r\n\r\n    get list() {\r\n        return this.stations\r\n    }\r\n\r\n    private save() { // save to local storage\r\n        localStorage.setItem(\"stations\", JSON.stringify(this.stations))\r\n        this.changed()\r\n    }\r\n\r\n    load() { // load from local storage\r\n        let stats = localStorage.getItem(\"stations\")\r\n        if (stats) {\r\n            this.stations = JSON.parse(stats)\r\n            this.changed()\r\n        }\r\n    }\r\n    \r\n    private updateCbs:UpdateCallback[] = []\r\n    onUpdated(ucb:UpdateCallback):UpdateCallback {\r\n        this.updateCbs.push(ucb)\r\n        return ucb\r\n    }\r\n\r\n    private changed() {\r\n        for (const cb of this.updateCbs)\r\n            cb()\r\n    }\r\n}\r\n\r\nexport const favorites = new Favorites()","import React from \"react\"\r\nimport { Station } from \"../functions/radioSearch\"\r\nimport RadioPlayer, {StatusCallback, LoadError} from \"../functions/radioPlayer\"\r\nimport { favorites } from \"../functions/favorites\"\r\n\r\nexport let radioPlayer = new RadioPlayer()\r\n\r\ninterface PlayerProps {\r\n    station:Station|undefined\r\n    className:string\r\n}\r\n\r\ninterface PlayerState {\r\n    status: string\r\n    detail?: string \r\n}\r\n\r\nexport default class Player extends React.Component<PlayerProps, PlayerState> {\r\n    state:PlayerState = {\r\n        status : \"stop\",\r\n        \r\n    }\r\n\r\n    private statusChangeId:StatusCallback|undefined\r\n    componentDidMount() {\r\n        this.statusChangeId = radioPlayer.onStatusChanged((status, detail) => {\r\n            if (radioPlayer.station && this.props.station?.id == radioPlayer.station.id) // only change state, if we display details for the station playing\r\n                this.setState({\r\n                    status,\r\n                    detail\r\n                })\r\n        })\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.statusChangeId)\r\n            radioPlayer.offStatusChanged(this.statusChangeId)\r\n    }\r\n\r\n    async togglePlayback() {\r\n        if (!this.props.station)\r\n            return\r\n        const stat = this.getPlayStatus()\r\n        if (stat != \"play\") {\r\n            try {\r\n                this.setState({status:\"load\", detail: undefined})\r\n                if (radioPlayer.station?.id != this.props.station.id)\r\n                    await radioPlayer.setStation(this.props.station)\r\n                radioPlayer.play()\r\n            } catch (loadErr) {\r\n                if (!(loadErr instanceof LoadError)) // no playback when loading fails. status change takes care of notifying the user\r\n                    throw loadErr\r\n            }\r\n        } else {\r\n            radioPlayer.stop()\r\n        }\r\n    }\r\n\r\n    getPlayStatus() {\r\n        let status = this.state.status // this can contain the last status updated by the player\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) {\r\n            status = \"stop\" // this stream hasn't been started\r\n        }\r\n        return status\r\n    }\r\n\r\n    getPlayDetail() {\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) \r\n            return undefined\r\n        else return this.state.detail\r\n    }\r\n\r\n    toggleFavorite() {\r\n        const station = this.props.station;\r\n        if (station) {\r\n            if (favorites.isFavorite(station)) favorites.remove(station)\r\n            else favorites.add(station)\r\n            this.setState({}) // needs update\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const station = this.props.station;\r\n        if (!station) return null\r\n        let status = this.getPlayStatus()\r\n        \r\n        const buttonTextByStatus = {\r\n            play: \"Stop\",\r\n            stop: \"Play\",\r\n            load: \"Loading\",\r\n            error: `Error ${this.state.detail ?? \"\"}`\r\n        }\r\n        let playButtonText = buttonTextByStatus[status] ?? \"Error\"\r\n        let detailText:JSX.Element | undefined\r\n        const detail = this.getPlayDetail()\r\n        if (detail) {\r\n            detailText = <span>{detail}</span>\r\n        }\r\n\r\n        return <div className={this.props.className}>\r\n                    <h2>{station.name}</h2>\r\n                    <p>in: {station.country}</p>\r\n                    <p>tags: {station.tags}</p>\r\n                    <div>\r\n                        <button onClick={e => this.togglePlayback()} >{playButtonText}</button> {/* toggle pause */}\r\n                        {detailText}\r\n                    </div>\r\n                    <div>\r\n                        <button onClick={()=> this.toggleFavorite()} >{favorites.isFavorite(station) ? \"Remove from favorites\" : \"Add to favorites\"}</button>\r\n                        <button>Vote!</button>\r\n                    </div>\r\n               </div>\r\n    }\r\n}","import React from 'react'\r\n\r\nexport default class About extends React.Component<{className:string}> {\r\n    render() {\r\n        return <div className={\"about \" + this.props.className} >\r\n            <h2>About</h2>\r\n            <p>\r\n                Open source webradio implementation using React. \r\n            </p>\r\n            <p>\r\n                Uses the api provided by <a href=\"http://www.radio-browser.info\">http://www.radio-browser.info</a>\r\n            </p>\r\n            <p>\r\n                If you find any issues, or have feature requests please report them at the project's github page: <a href=\"https://github.com/bxantus/webradio\">https://github.com/bxantus/webradio</a>\r\n            </p>\r\n        </div>\r\n    }\r\n}","import React from 'react';\r\nimport RadioSearch from './components/search'\r\nimport RadioPlayerUI, { radioPlayer } from './components/player'\r\nimport { Station } from './functions/radioSearch';\r\nimport About from './components/about';\r\nimport StationList from './components/stationList';\r\nimport { favorites } from './functions/favorites';\r\nimport { getLastPlayedStation } from './functions/lastPlayed';\r\n\r\ninterface RadioState {\r\n    selectedTab:string\r\n    selectedStation?:Station\r\n}\r\n\r\ninterface Tab {\r\n    title: string\r\n    content: (cls:string) => JSX.Element\r\n}\r\n\r\nexport default class WebradioApp extends React.Component<{}, RadioState> {\r\n    state:RadioState = {\r\n        selectedTab: \"Search\",\r\n    }\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        favorites.load();\r\n    }\r\n\r\n    componentDidMount() {\r\n        favorites.onUpdated(() => {\r\n            this.setState({}) // update\r\n        })\r\n        const lastPlayed = getLastPlayedStation()\r\n        if (lastPlayed) {\r\n            radioPlayer.setStation(lastPlayed)\r\n            this.stationSelected(lastPlayed) // switch to play tab\r\n        }\r\n    }\r\n\r\n    get tabs() {\r\n        return [\r\n            { title: \"Search\", content: (cls:string) => <RadioSearch className={cls} onStationSelected={station=> this.stationSelected(station)}>Search content</RadioSearch> },\r\n            { title: \"Favorites\", content: (cls:string) => <div className={\"scrollable \" + cls}><StationList stations={favorites.list} onStationSelected={station=> this.stationSelected(station)} ></StationList></div> },\r\n            { title: \"Play\", content: (cls:string) => <RadioPlayerUI className={cls} station={this.state.selectedStation}></RadioPlayerUI> },\r\n            { title: \"About\", content: (cls:string) => <About className={cls} ></About>}\r\n        ]\r\n    }\r\n\r\n    changeTab(tab:Tab, userSelect=true)  {\r\n        this.setState({\r\n            selectedTab: tab.title\r\n        })\r\n        if (userSelect) {\r\n            this.setState({\r\n                selectedStation: radioPlayer.station\r\n            })\r\n        }\r\n    }\r\n\r\n    stationSelected(station:Station) {\r\n        this.setState({\r\n            selectedStation: station\r\n        })\r\n        this.changeTab(this.tabs[2], /*userSelect*/false)  \r\n    }\r\n\r\n    render() {\r\n        const tabs = this.tabs\r\n        const selectedTabName = this.state.selectedTab\r\n        const selectedTab = tabs.find(tab => tab.title === selectedTabName)\r\n        const headerContent = tabs.map(tab => <span className={tab === selectedTab ? \"tab selected\" : \"tab\"}\r\n                                                    key={tab.title} onClick={e=>this.changeTab(tab)} >{tab.title}</span> )\r\n        const tabElements = tabs.map(tab => tab.content(tab == selectedTab ? \"visible\" : \"hidden\"))\r\n        \r\n        return (\r\n            <div className=\"radio-App flexible vertical\">\r\n                <div className=\"tabs\">{headerContent}</div>\r\n                {tabElements}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport WebRadio from './webradio'\n\nReactDOM.render(\n  <React.StrictMode>\n    <WebRadio>my text</WebRadio>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}