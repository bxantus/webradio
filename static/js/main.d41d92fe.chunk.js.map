{"version":3,"sources":["components/stationList.tsx","components/search.tsx","functions/radioApi.ts","functions/lastPlayed.ts","functions/radioPlayer.ts","functions/favorites.ts","components/slider.tsx","models/base.ts","models/range.ts","components/player.tsx","components/about.tsx","webradio.tsx","functions/searchModel.ts","index.tsx"],"names":["StationList","stations","this","props","map","station","className","onClick","onStationSelected","key","id","name","tags","replace","country","length","src","votes","codec","bitrate","React","Component","Search","searchList","state","results","undefined","searching","createRef","search","subscribe","setState","res","current","scrollTop","ref","toStation","r","stationuuid","language","icon","favicon","RadioSearch","query","offset","_hasMoreResults","limit","url","apiUrl","fetch","then","json","push","getStreamUrl","a","refreshStation","voteForStation","ok","needsUpgrade","upgradeStation","refreshed","getLastPlayedStation","stat","localStorage","getItem","JSON","parse","saveLastPlayedStation","setItem","stringify","LoadError","message","Error","RadioPlayer","player","statusEmitter","loading","_volume","off","stop","unload","fireStatusChange","loadPlayer","Howl","autoplay","html5","preload","on","_","error","playing","volume","play","newStatus","detail","cb","idx","findIndex","val","splice","vol","favorites","updateCbs","isFavorite","save","find","changed","stats","upgrades","Promise","all","ucb","Slider","valueChangeSub","posStartDrag","valStart","sliderBg","thumb","sliderProgress","dragging","moveListener","e","onPointerMove","upListener","onPointerUp","model","updateSliderStyles","setAttribute","unsubscribe","trackSize","clientWidth","thumbWidth","pos","min","max","posCross","clientHeight","offs","clientX","change","window","addEventListener","removeEventListener","onPointerDown","children","SubscriptionRepository","subs","Map","changeFunc","subsForName","get","set","sub","onChange","newVal","RangeModel","_min","_max","_val","updateValue","prop","add","notifyFor","radioPlayer","Player","status","voting","statusChangeId","onStatusChanged","offStatusChanged","getPlayStatus","setStation","remove","buttonIcon","load","getPlayDetail","favoriteHeader","toggleFavorite","togglePlayback","vote","disabled","draggable","About","target","href","currentSearch","searchTimer","timeout","clearTimeout","setTimeout","hasMoreResults","WebradioApp","selectedTab","searchTab","title","content","cls","stationSelected","searchInput","focusOnSearch","onUpdated","lastPlayed","tab","userSelect","selectedStation","changeTab","tabs","value","scheduleSearch","focus","selectedTabName","tabTitles","selection","tabContent","concat","searchSelected","defaultValue","searchText","onInput","searchTextChanged","selectSearch","list","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d41d92fe.chunk.js","sourcesContent":["import React from \"react\"\r\nimport { Station } from \"../functions/radioApi\";\r\n\r\ninterface StationsProps {\r\n    stations?: Station[]\r\n    onStationSelected?: (station:Station) => any\r\n}\r\n\r\n// tags are retrieved in a format split by commas, but no preceding space\r\nfunction formatTags(tags:string) {\r\n    return tags.replace(/,(?=[^\\s])/g, \", \")\r\n}\r\n\r\nfunction formatCountry(country:string) {\r\n    return country.length > 0 ? country : \"Unknown\"\r\n}\r\n\r\nexport default class StationList extends React.Component<StationsProps, {}> {\r\n    render() {\r\n        const stations = this.props.stations;\r\n        if (stations) {\r\n            let results = stations.map(station => \r\n                <div className=\"clickable station\" onClick={ () => this.props?.onStationSelected?.(station) } key={station.id}>\r\n                    <h3>{station.name}</h3>\r\n                    <div className=\"tags\">{formatTags(station.tags)}</div>\r\n                    <div className=\"flexible horizontal details\">\r\n                        <span className=\"country\">{formatCountry(station.country)}</span>\r\n                        <img className=\"votes\" src=\"/webradio/icons/votes.svg\"></img>\r\n                        <span className=\"flex1\">{station.votes}</span>\r\n                        <span className=\"codec\">{station.codec} - {station.bitrate} kbps</span>\r\n                    </div>\r\n                    <hr></hr>\r\n                </div> )\r\n            return results\r\n        } else return null\r\n    }\r\n}","import React from 'react';\r\nimport { Station } from '../functions/radioApi';\r\nimport SearchModel from '../functions/searchModel'\r\nimport StationList from './stationList';\r\n\r\ninterface SearchState {\r\n    results: Station[] | undefined\r\n    searching:boolean\r\n}\r\n\r\ninterface SearchProps {\r\n    onStationSelected?:(station:Station)=> any\r\n    className?: string\r\n    search:SearchModel\r\n}\r\n\r\nexport default class Search extends React.Component<SearchProps, SearchState> {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            results: undefined, // todo: get current results from SearchModel\r\n            searching: false\r\n        }\r\n        this.searchList = React.createRef<HTMLDivElement>()\r\n    }\r\n\r\n    componentWillMount() {\r\n        const search = this.props.search\r\n        search.subscribe(\"searching\", (searching:boolean)=> {\r\n            this.setState({searching: searching})\r\n        })\r\n        search.subscribe(\"results\", (res:Station[])=> {\r\n            this.setState({results: res})\r\n        })\r\n        search.subscribe(\"query\", ()=> {\r\n            if (this.searchList.current) this.searchList.current.scrollTop = 0\r\n        })\r\n    }\r\n\r\n    private searchList:React.RefObject<HTMLDivElement>\r\n\r\n    render() {\r\n        const results = this.state.results\r\n        \r\n        // NOTE: based on `this.state.searching` we could present some searching progress\r\n        \r\n        return (\r\n            <div className={\"search flexible vertical \" + (this.props.className ?? \"\")}>\r\n                \r\n                <div ref={this.searchList} className=\"results\">\r\n                    <StationList stations={results} onStationSelected={this.props?.onStationSelected}></StationList>\r\n                </div>\r\n                \r\n            </div>\r\n        )\r\n    }\r\n}","\r\nexport interface Query {\r\n    name: string;\r\n    tags?: string;\r\n    limit?: number;\r\n}\r\n\r\nexport interface Station {\r\n    name: string\r\n    id: string,\r\n    tags: string,\r\n    country: string,\r\n    language: string,\r\n    icon: string,\r\n    votes: number,\r\n    // fields below are added to v1\r\n    codec:string,              \r\n    bitrate:number,            \r\n}\r\n\r\n/// station format from api.radio-browser\r\ninterface RadioStation { \r\n    /** A globally unique identifier for the change of the station information */\r\n    changeuuid:string,         \r\n    /**A globally unique identifier for the station */\r\n    stationuuid:string,        \r\n    /**  The name of the station */\r\n    name:string, \t           \r\n    /**  URL (HTTP/HTTPS) \tThe stream URL provided by the user*/\r\n    url:string,                \r\n    /** URL (HTTP/HTTPS) \tAn automatically \"resolved\" stream URL. Things resolved are playlists (M3U/PLS/ASX...), HTTP redirects (Code 301/302). This link is especially usefull if you use this API from a platform that is not able to do a resolve on its own (e.g. JavaScript in browser) or you just don't want to invest the time in decoding playlists yourself. */\r\n    url_resolved:string,       \r\n    /** URL (HTTP/HTTPS) \tURL to the homepage of the stream, so you can direct the user to a page with more information about the stream. */\r\n    homepage:string,           \r\n    /**  URL (HTTP/HTTPS) \tURL to an icon or picture that represents the stream. (PNG, JPG)*/\r\n    favicon:string,            \r\n    /** multivalue, split by comma \tTags of the stream with more information about it */\r\n    tags:string,               \r\n    /** DEPRECATED: use countrycode instead, full name of the country */ \r\n    country:string             \r\n    /** 2 letters, uppercase \tOfficial countrycodes as in ISO 3166-1 alpha-2 */\r\n    countrycode:string,        \r\n    /**  Full name of the entity where the station is located inside the country*/\r\n    state:string,              \r\n    /** multivalue, split by comma \tLanguages that are spoken in this stream. */\r\n    language:string,           \r\n    /** integer \tNumber of votes for this station. This number is by server and only ever increases. It will never be reset to 0. */\r\n    votes:number,              \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tLast time when the stream information was changed in the database */\r\n    lastchangetime:string,     \r\n    /** The codec of this stream recorded at the last check. */\r\n    codec:string,              \r\n    /** integer, bps \tThe bitrate of this stream recorded at the last check. */\r\n    bitrate:number,            \r\n    /** 0 or 1 \tMark if this stream is using HLS distribution or non-HLS. */\r\n    hls:number,                \r\n    /** 0 or 1 \tThe current online/offline state of this stream. This is a value calculated from multiple measure points in the internet. \r\n     * The test servers are located in different countries. It is a majority vote. */\r\n    lastcheckok: number        \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when any radio-browser server checked the online state of this stream */\r\n    lastchecktime:string,      \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when the stream was checked for the online status with a positive result */\r\n    lastcheckoktime:string,    \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe last time when this server checked the online state and the metadata of this stream */\r\n    lastlocalchecktime:string, \r\n    /** datetime, YYYY-MM-DD HH:mm:ss \tThe time of the last click recorded for this stream */\r\n    clicktimestamp:string,     \r\n    /** integer \tClicks within the last 24 hours */\r\n    clickcount:number,         \r\n    /** integer \tThe difference of the clickcounts within the last 2 days. Posivite values mean an increase, negative a decrease of clicks. */\r\n    clicktrend:number,         \r\n}\r\n\r\nfunction toStation(r:RadioStation):Station {\r\n    return {  name: r.name,\r\n              id: r.stationuuid,\r\n              tags: r.tags,\r\n              country: r.country,\r\n              language: r.language,\r\n              icon: r.favicon,\r\n              votes: r.votes,\r\n              codec: r.codec,\r\n              bitrate: r.bitrate\r\n    }\r\n}\r\n\r\n// api docs at: https://api.radio-browser.info/\r\n// and https://de1.api.radio-browser.info/#Advanced_station_search\r\nexport class RadioSearch {\r\n    public query: Query\r\n    private offset = 0\r\n    private _hasMoreResults = false\r\n\r\n    results:Station[] = []\r\n    constructor(query: Query) {\r\n        this.query = query\r\n        if (this.query.limit == undefined)\r\n            this.query.limit = 20\r\n    }\r\n\r\n    /// @return with the number of stations found\r\n    async search() {\r\n        // compute url\r\n        let url = `${apiUrl}/stations/search?name=${this.query.name}&order=votes&reverse=true&limit=${this.query.limit}&offset=${this.offset}`\r\n        // do the stuff\r\n        let results = await fetch(url).then(res => res.json())\r\n        let res:Station[] = results.map(toStation)\r\n        this.results.push(...res)\r\n        this.offset = this.results.length\r\n        this._hasMoreResults = res.length == this.query.limit // when fever results are returned, then no more results are available\r\n    }\r\n\r\n    get hasMoreResults() { return this._hasMoreResults }\r\n}\r\n\r\nexport async function getStreamUrl(station:Station) {\r\n    var url = `${apiUrl}/url/${station.id}`;\r\n    var res = await fetch(url).then(res=>res.json())\r\n    if (res && res.url)\r\n        return res.url as string;\r\n    else return undefined;\r\n}\r\n\r\nexport async function refreshStation(station:Station) {\r\n    var url = `${apiUrl}/stations/byuuid/${station.id}` // get info for this station only\r\n    var res = await fetch(url).then(res=>res.json())\r\n    // will return an array with one item\r\n    if (res && res[0]) {\r\n        return toStation(res[0])\r\n    }\r\n}\r\n\r\nexport async function voteForStation(station:Station) {\r\n    var url = `${apiUrl}/vote/${station.id}`; \r\n    // will return status of vote (in the ok field)\r\n    try {\r\n        var res = await fetch(url)\r\n        if (res.ok) {\r\n            res = await res.json()\r\n            return res.ok\r\n        } else return false\r\n    } catch (err) {\r\n        return false\r\n    }\r\n}\r\n\r\nconst apiUrl = \"https://de1.api.radio-browser.info/json\" // todo: should do dns lookup as the docs ask\r\n\r\nexport function needsUpgrade(station:Station) {\r\n    // from v0 to v1 (codec and bitrate added)\r\n    return station.codec == undefined || station.bitrate == undefined;\r\n}\r\n\r\nexport async function upgradeStation(station:Station) {\r\n    let refreshed = await refreshStation(station)\r\n    if (refreshed) {\r\n        station.codec = refreshed.codec;\r\n        station.bitrate = refreshed.bitrate;\r\n        // could refresh all fields but only these have been added\r\n        return true\r\n    }\r\n    return false\r\n}","import { Station, needsUpgrade, upgradeStation } from \"./radioApi\";\r\n\r\nexport async function getLastPlayedStation():Promise<Station | undefined> {\r\n    const stat = localStorage.getItem(\"lastPlayed\")\r\n    if (stat) {\r\n        let station:Station = JSON.parse(stat)\r\n        if (needsUpgrade(station))\r\n            await upgradeStation(station)\r\n        return station\r\n    }\r\n}\r\n\r\nexport function saveLastPlayedStation(station:Station) {\r\n    localStorage.setItem(\"lastPlayed\", JSON.stringify(station))\r\n}","import { Howl } from \"howler\"\r\nimport { Station, getStreamUrl } from \"./radioApi\"\r\nimport { saveLastPlayedStation } from \"./lastPlayed\"\r\n\r\nexport type StatusCallback = (status:string, detail?:string)=>any\r\n\r\nexport class LoadError extends Error{\r\n    constructor(message:string) {\r\n        super(message)\r\n        this.name = \"LoadError\"\r\n    }\r\n}\r\n\r\nexport default class RadioPlayer {\r\n    player:Howl|undefined\r\n    station:Station|undefined\r\n    private statusEmitter:StatusCallback[] = []\r\n    private loading:Promise<void>|undefined\r\n\r\n    async setStation(station:Station) {\r\n        // stop old player\r\n        if (this.player) {\r\n            this.player.off() // remove old events, and stop\r\n            this.player.stop()\r\n            this.player.unload()\r\n            this.player = undefined\r\n        }\r\n        // todo: use subscription repository and notify about station change in the player\r\n        //       status change also should be fired through subs repo\r\n        this.fireStatusChange(\"load\", \"station\")\r\n        this.station = station\r\n        \r\n        saveLastPlayedStation(station)\r\n        // will save loading promise, as users may use play while station url is loading\r\n        // in these cases play should progress as well (see play)\r\n        this.loading = this.loadPlayer(station)\r\n        return this.loading\r\n    }\r\n\r\n    private async loadPlayer(station:Station) {\r\n        // get station url ...\r\n        let url = await getStreamUrl(station)\r\n        this.loading = undefined\r\n        if (!url) {\r\n            this.fireStatusChange(\"error\", \"cannot resolve station url\")\r\n            throw new LoadError(\"cannot resolve station url\")\r\n        } \r\n        if (this.station?.id == station.id) { // haven't changed stations meanwhile\r\n            if (this.player) {\r\n                this.player.off()\r\n                this.player.unload() // if somehow an old player gets stuck, unload it\r\n            }\r\n            this.player = new Howl({src: url, autoplay: false, html5: true, preload: false})\r\n            this.fireStatusChange(\"stop\")\r\n            this.player.on('load', ()=> this.fireStatusChange(\"load\", \"start playing\"))\r\n            this.player.on('play', ()=> this.fireStatusChange(\"play\") )\r\n            this.player.on('stop', ()=> this.fireStatusChange(\"stop\") )\r\n            this.player.on('pause', ()=> this.fireStatusChange(\"stop\") )\r\n\r\n            // NOTE: howl will fire load errors for radio streams, without extension, if you call the `load()` method\r\n            //       this is probably a bug? (as play will report no errors)\r\n            this.player.on('loaderror', (_, error)=> this.fireStatusChange(\"error\", \"loading the stream failed: \" + error))\r\n            this.player.on('playerror', (_, error)=> this.fireStatusChange(\"error\", \"playback error: \" + error))\r\n        } else {\r\n            throw new LoadError(\"changed stations while loading\")\r\n        }\r\n    }\r\n\r\n    async play() {\r\n        try {\r\n            if (this.loading)\r\n                await this.loading\r\n        } catch (err) {\r\n            if (err instanceof LoadError)\r\n                return; // can't play this stream\r\n            else throw err // rethrow other errors\r\n        }\r\n        \r\n        if (this.player && !this.player.playing()) {\r\n            // when not loaded\r\n            if (this.player.state() == \"unloaded\") {\r\n                this.fireStatusChange(\"load\", \"stream\")\r\n                // no need to use `load`, see the loadError remark. play will load the stream\r\n            }\r\n            this.player.volume(this._volume / 100)\r\n            this.player.play()\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        if (this.player) {\r\n            this.player.stop()\r\n            this.player.unload() // preserve battery\r\n        }\r\n    }\r\n\r\n    private _volume:number = 100\r\n    // set the volume in 0 to 100 range\r\n    set volume(vol:number) {\r\n        this._volume = vol\r\n        if (this.player) {\r\n            this.player.volume(vol / 100) // howler works with 0 and 1 range\r\n        }\r\n    }\r\n\r\n    private fireStatusChange(newStatus:string, detail?:string) {\r\n        for (let cb of this.statusEmitter) {\r\n            cb(newStatus, detail)\r\n        }\r\n    }\r\n\r\n    onStatusChanged(cb: StatusCallback) {\r\n        this.statusEmitter.push(cb)\r\n        return cb\r\n    }\r\n\r\n    offStatusChanged(cb:StatusCallback) {\r\n        const idx = this.statusEmitter.findIndex(val => cb == val)\r\n        if (idx >= 0)\r\n            this.statusEmitter.splice(idx, 1)\r\n    }\r\n}","import { Station, needsUpgrade, upgradeStation } from \"./radioApi\";\r\n\r\nexport type UpdateCallback = () => any\r\n\r\n// uses localStorage to keep a list of favorite stations\r\nclass Favorites {\r\n    private stations:Station[] = []\r\n    \r\n    add(station:Station) {\r\n        if (!this.isFavorite(station)) {\r\n            this.stations.push(station)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    remove(station:Station) {\r\n        const idx = this.stations.findIndex(val => val.id == station.id)\r\n        if (idx >= 0) {\r\n            this.stations.splice(idx, 1)\r\n            this.save()\r\n        }\r\n    }\r\n\r\n    isFavorite(station:Station):boolean {\r\n        const stat = this.stations.find(val => val.id == station.id)\r\n        return stat != undefined\r\n    }\r\n\r\n    get list() {\r\n        return this.stations\r\n    }\r\n\r\n    private save() { // save to local storage\r\n        localStorage.setItem(\"stations\", JSON.stringify(this.stations))\r\n        this.changed()\r\n    }\r\n\r\n    async load() { // load from local storage\r\n        let stats = localStorage.getItem(\"stations\")\r\n        if (stats) {\r\n            let stations:Station[] = JSON.parse(stats)\r\n            // check for upgrades\r\n            let upgrades:Promise<boolean>[] = []\r\n            for (let station of stations) {\r\n                if (needsUpgrade(station)) {\r\n                    upgrades.push(upgradeStation(station))\r\n                }\r\n            }\r\n            try {\r\n                if (upgrades.length) {\r\n                    await Promise.all(upgrades)\r\n                    this.stations = stations\r\n                    this.save() // save upgraded stations, so next time they don't have to be upgraded\r\n                }\r\n            } finally {\r\n                if (this.stations != stations) {\r\n                    this.stations = stations\r\n                    this.changed()\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateCbs:UpdateCallback[] = []\r\n    onUpdated(ucb:UpdateCallback):UpdateCallback {\r\n        this.updateCbs.push(ucb)\r\n        return ucb\r\n    }\r\n\r\n    private changed() {\r\n        for (const cb of this.updateCbs)\r\n            cb()\r\n    }\r\n}\r\n\r\nexport const favorites = new Favorites()","import React from \"react\"\r\nimport { RangeModel } from \"../models/range\"\r\nimport { Subscription } from \"../models/base\"\r\n\r\ninterface SliderProps {\r\n    model:RangeModel\r\n}\r\n\r\nexport class Slider extends React.Component<SliderProps> {\r\n    get model() { return this.props.model }\r\n    private valueChangeSub:Subscription|undefined\r\n\r\n    componentDidMount() {\r\n        this.valueChangeSub = this.model.subscribe(\"value\", () => {\r\n            this.updateSliderStyles() // update thumb and progress pos\r\n        })\r\n        \r\n        this.setState({}) // trigger a refresh, so refs get sizes\r\n        if (this.thumb.current) {\r\n            this.thumb.current.setAttribute(\"touch-action\",  \"none\") // in order for the pointerEvent polyfill to work\r\n        }\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        this.updateSliderStyles() // style refresh\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.valueChangeSub) this.valueChangeSub.unsubscribe()\r\n    }\r\n\r\n    private updateSliderStyles() {\r\n        if (this.sliderBg.current && this.thumb.current) {\r\n            let model = this.model;\r\n            const trackSize = this.sliderBg.current.clientWidth - this.thumb.current.clientWidth\r\n            const thumbWidth = this.thumb.current.clientWidth\r\n            let pos = (model.val - model.min) * trackSize / (model.max - model.min) // left pos on track\r\n            let posCross = -(this.thumb.current.clientHeight - this.sliderBg.current.clientHeight) / 2;\r\n            this.thumb.current.setAttribute(\"style\", `left: ${pos}px; top:${posCross}px`)\r\n            if (this.sliderProgress.current) {\r\n                this.sliderProgress.current.setAttribute(\"style\", `width: ${pos + thumbWidth / 2}px`)\r\n            }\r\n        }\r\n    }\r\n\r\n    private posStartDrag = 0\r\n    private valStart = 0\r\n    private sliderBg = React.createRef<HTMLDivElement>()\r\n    private thumb = React.createRef<HTMLSpanElement>()\r\n    private sliderProgress = React.createRef<HTMLDivElement>()\r\n    private dragging = false\r\n\r\n    onPointerMove(e:MouseEvent) {\r\n        if (this.dragging && this.sliderBg.current && this.thumb.current) {\r\n            \r\n            const trackSize = this.sliderBg.current.clientWidth - this.thumb.current.clientWidth // corresponds to change in range max - min\r\n            let offs = e.clientX - this.posStartDrag\r\n            if (trackSize > 0) {\r\n                let change = offs * (this.model.max - this.model.min) / trackSize\r\n                this.model.val = this.valStart + change // this will update the display automatically\r\n            }\r\n        }\r\n    }\r\n\r\n    moveListener = (e:MouseEvent) => this.onPointerMove(e)\r\n    upListener = (e:MouseEvent) => this.onPointerUp(e)\r\n\r\n    onPointerDown(e:React.MouseEvent) {\r\n        // todo: check button/finger here\r\n        this.posStartDrag = e.clientX\r\n        this.valStart = this.model.val;\r\n        this.dragging = true\r\n        window.addEventListener(\"pointermove\", this.moveListener)\r\n        window.addEventListener(\"pointerup\", this.upListener)\r\n    }\r\n\r\n    onPointerUp(e:MouseEvent) {\r\n        this.dragging = false\r\n        window.removeEventListener(\"mousemove\", this.moveListener)\r\n        window.removeEventListener(\"mouseup\", this.upListener)\r\n    }\r\n\r\n    render() {\r\n        return <div className=\"slider bg\" ref={this.sliderBg}>\r\n                    <div className=\"slider progress\" ref={this.sliderProgress}></div>\r\n                    <span className=\"thumb\" ref={this.thumb} \r\n                          onPointerDown={e=>this.onPointerDown(e)}>\r\n                        {this.props.children}\r\n                    </span>\r\n               </div>\r\n    }\r\n}","export interface Subscription {\r\n    unsubscribe():void\r\n}\r\n\r\nexport interface Subscriber<T> {\r\n    onChange(newVal:T):void\r\n}\r\n\r\nexport class SubscriptionRepository {\r\n    add(name:string, changeFunc:(newVal:any) => void):Subscription {\r\n        let subsForName = this.subs.get(name) || []\r\n        if (subsForName.length == 0) {\r\n            this.subs.set(name, subsForName)\r\n        }\r\n\r\n        let sub = { onChange: changeFunc }\r\n        subsForName.push(sub)\r\n        return {\r\n            unsubscribe: () => {\r\n                const idx = subsForName.findIndex(val => val == sub)\r\n                if (idx >= 0) subsForName.splice(idx)\r\n            }\r\n        }\r\n    }\r\n\r\n    notifyFor(name:string, newVal:any) {\r\n        let subsForName = this.subs.get(name)\r\n        if (subsForName)\r\n            for (let s of subsForName) s.onChange(newVal)\r\n    }\r\n\r\n    private subs = new Map<string, Subscriber<any>[]>()\r\n}\r\n\r\n","import { Subscription, SubscriptionRepository } from \"./base\"\r\n\r\n// model reperesenting range and value \r\nexport class RangeModel { \r\n    private _min:number = 0\r\n    private _max:number = 100\r\n    private _val:number = 0\r\n    \r\n    get val():number { return this._val }\r\n    get min():number { return this._min }\r\n    get max():number { return this._max }\r\n\r\n    set val(newVal:number) {\r\n        if (newVal < this._min) newVal = this._min\r\n        else if (newVal > this._max) newVal = this._max\r\n        this.updateValue(newVal)\r\n    }\r\n\r\n    /// replace range, if min or max is not given the old values are used\r\n    setRange(min:number|undefined, max:number|undefined) {\r\n        if (min == undefined) min = this._min\r\n        if (max == undefined) max = this._max\r\n        if (min >= max) \r\n            throw new Error(`Invalid range! (min < max) should hold. Got: ${min} >= ${max}`)\r\n        this._min = min\r\n        this._max = max\r\n        if (this._val < min)\r\n            this.updateValue(min)\r\n        else if (this._val > max)\r\n            this.updateValue(max)\r\n    }\r\n\r\n    // subscribe for changes in value\r\n    subscribe(prop:\"value\", changeFunc:(v:number) => void):Subscription {\r\n        return this.subs.add(prop, changeFunc)\r\n    }\r\n\r\n    private updateValue(newVal:number) {\r\n        if (this._val != newVal) {\r\n            this._val = newVal\r\n            this.subs.notifyFor(\"value\", newVal)\r\n        }\r\n    }\r\n\r\n    private subs = new SubscriptionRepository()\r\n}\r\n","import React from \"react\"\r\nimport { Station, voteForStation, refreshStation } from \"../functions/radioApi\"\r\nimport RadioPlayer, {StatusCallback, LoadError} from \"../functions/radioPlayer\"\r\nimport { favorites } from \"../functions/favorites\"\r\nimport { Slider } from \"./slider\"\r\nimport { RangeModel } from \"../models/range\"\r\n\r\nexport let radioPlayer = new RadioPlayer()\r\n\r\ninterface PlayerProps {\r\n    station:Station|undefined\r\n    className:string\r\n}\r\n\r\ninterface PlayerState {\r\n    status: string\r\n    detail?: string \r\n    voting: boolean\r\n}\r\n\r\nexport default class Player extends React.Component<PlayerProps, PlayerState> {\r\n    state:PlayerState = {\r\n        status : \"stop\",\r\n        voting: false\r\n    }\r\n\r\n    private statusChangeId:StatusCallback|undefined\r\n    private volume = new RangeModel()\r\n    componentDidMount() {\r\n        this.statusChangeId = radioPlayer.onStatusChanged((status, detail) => {\r\n            if (radioPlayer.station && this.props.station?.id == radioPlayer.station.id) // only change state, if we display details for the station playing\r\n                this.setState({\r\n                    status,\r\n                    detail\r\n                })\r\n        });\r\n\r\n        this.volume.val = 75; // // todo: should use persisted value and set to radio player\r\n        this.volume.subscribe(\"value\", vol => radioPlayer.volume = vol)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.statusChangeId)\r\n            radioPlayer.offStatusChanged(this.statusChangeId)\r\n    }\r\n\r\n    async togglePlayback() {\r\n        if (!this.props.station)\r\n            return\r\n        const stat = this.getPlayStatus()\r\n        if (stat != \"play\") {\r\n            try {\r\n                this.setState({status:\"load\", detail: undefined})\r\n                if (radioPlayer.station?.id != this.props.station.id)\r\n                    await radioPlayer.setStation(this.props.station)\r\n                radioPlayer.play()\r\n            } catch (loadErr) {\r\n                if (!(loadErr instanceof LoadError)) // no playback when loading fails. status change takes care of notifying the user\r\n                    throw loadErr\r\n            }\r\n        } else {\r\n            radioPlayer.stop()\r\n        }\r\n    }\r\n\r\n    getPlayStatus() {\r\n        let status = this.state.status // this can contain the last status updated by the player\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) {\r\n            status = \"stop\" // this stream hasn't been started\r\n        }\r\n        return status\r\n    }\r\n\r\n    getPlayDetail() {\r\n        if (this.props.station && this.props.station.id != radioPlayer.station?.id) \r\n            return undefined\r\n        else return this.state.detail\r\n    }\r\n\r\n    toggleFavorite() {\r\n        const station = this.props.station;\r\n        if (station) {\r\n            if (favorites.isFavorite(station)) favorites.remove(station)\r\n            else favorites.add(station)\r\n            this.setState({}) // needs update\r\n        }\r\n    }\r\n\r\n    async vote() {\r\n        if (!this.props.station) return\r\n        this.setState({voting: true})\r\n        const succ = await voteForStation(this.props.station)\r\n        \r\n        const refreshed = await refreshStation(this.props.station)\r\n        if (refreshed) {\r\n            this.props.station.votes = refreshed.votes\r\n        }\r\n        \r\n        this.setState({voting: false}) \r\n    }\r\n\r\n    render() {\r\n        const station = this.props.station;\r\n        if (!station) return null\r\n        let status = this.getPlayStatus()\r\n        \r\n        const iconsForStatus = {\r\n            play: \"stop.svg\",\r\n            stop: \"play.svg\",\r\n            load: \"loading.svg\",\r\n        }\r\n\r\n        const buttonIcon =  status != \"error\" ? `/webradio/icons/${iconsForStatus[status]}` : \"\";  \r\n        const detail = this.getPlayDetail()\r\n        \r\n\r\n        const isFavorite = favorites.isFavorite(station)\r\n        const favoriteHeader = isFavorite\r\n                                    ? (<span>\r\n                                          <img className=\"small-ico like\" src=\"/webradio/icons/like.svg\"></img>\r\n                                          Favorite\r\n                                       </span>\r\n                                      )\r\n                                    : undefined;\r\n\r\n        return <div className={this.props.className + \" flexible vertical player\"}>\r\n                    <div className=\"player-header flexible horizontal\">\r\n                        <span>{station.country}</span>\r\n                        <span>\r\n                            <img className=\"small-ico\" src=\"/webradio/icons/votes.svg\"></img>\r\n                            {station.votes}\r\n                        </span>\r\n                        {favoriteHeader}\r\n                    </div>\r\n                    <h2 className=\"title\">{station.name}</h2>\r\n                    <p className=\"tags\">{station.tags}</p>\r\n                    <button className=\"favorite-toggle\" onClick={()=> this.toggleFavorite()} >\r\n                        <img className=\"small-ico like\" src={isFavorite ? \"/webradio/icons/unlike.svg\" : \"/webradio/icons/like.svg\"}></img>\r\n                        <span className=\"text\">{isFavorite ? \"Remove Favorite\" : \"Add as Favorite\"}</span>\r\n                    </button>\r\n                    <div className=\"play-area\">\r\n                        <button className=\"play\" onClick={e => this.togglePlayback()} >\r\n                            <img className={`play-ico ${status}`} src={buttonIcon}></img>\r\n                        </button> \r\n                        {\r\n                            // todo: add overlay for error messages\r\n                        }\r\n                    </div>\r\n                    <div className=\"flexible horizontal play-footer\">\r\n                        <span className=\"flex1\">{station.codec} - {station.bitrate} kbps</span>\r\n                        <button className=\"vote\" onClick={()=> this.vote() }disabled={this.state.voting} >\r\n                            <img className=\"small-ico\" src=\"/webradio/icons/votes.svg\"></img>\r\n                            Vote\r\n                        </button> \r\n                    </div>\r\n                    \r\n                    <Slider model={this.volume} >\r\n                        <img className=\"volume\" src=\"/webradio/icons/volume.svg\" draggable=\"false\"></img>\r\n                    </Slider>\r\n               </div>\r\n    }\r\n}","import React from 'react'\r\n\r\nexport default class About extends React.Component<{className:string}> {\r\n    render() {\r\n        return <div className={\"about \" + this.props.className} >\r\n            <h2>About webradio</h2>\r\n            <p>\r\n                Open source webradio implementation using React. \r\n            </p>\r\n            <p>\r\n                Uses the api provided by <a target=\"blank\" href=\"http://www.radio-browser.info\">www.radio-browser.info</a>\r\n            </p>\r\n            <p>\r\n                If you find any issues, or have feature requests please report them at the project's github page: <a href=\"https://github.com/bxantus/webradio\" target=\"blank\">github.com/bxantus/webradio</a>\r\n            </p>\r\n            <a href=\"https://bxantus.github.io/webradio/index.html\">\r\n                <img className=\"qr-code\" src=\"/webradio/address_qr.png\"></img>\r\n            </a>\r\n            <h4>Link for mobile devices:</h4>\r\n            <p className=\"small-margin\">\r\n                Scan the code to the right on a mobile phone to open webradio on it!\r\n            </p>\r\n        </div>\r\n    }\r\n}","import React from 'react';\r\nimport RadioSearch from './components/search'\r\nimport RadioPlayerUI, { radioPlayer } from './components/player'\r\nimport { Station } from './functions/radioApi';\r\nimport About from './components/about';\r\nimport StationList from './components/stationList';\r\nimport { favorites } from './functions/favorites';\r\nimport { getLastPlayedStation } from './functions/lastPlayed';\r\nimport SearchModel from './functions/searchModel'\r\n\r\ninterface RadioState {\r\n    selectedTab:string\r\n    selectedStation?:Station\r\n}\r\n\r\ninterface Tab {\r\n    title: string\r\n    content: (cls:string) => JSX.Element\r\n}\r\n\r\nlet currentSearch= new SearchModel\r\n\r\nexport default class WebradioApp extends React.Component<{}, RadioState> {\r\n    state:RadioState = {\r\n        selectedTab: \"Search\",\r\n    }\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        favorites.load();\r\n    }\r\n\r\n    async componentDidMount() {\r\n        favorites.onUpdated(() => {\r\n            this.setState({}) // update\r\n        })\r\n        const lastPlayed = await getLastPlayedStation()\r\n        if (lastPlayed) {\r\n            radioPlayer.setStation(lastPlayed)\r\n            this.stationSelected(lastPlayed) // switch to play tab\r\n        }\r\n    }\r\n\r\n    get tabs() {\r\n        return [\r\n            { title: \"Favorites\", content: (cls:string) => <div className={cls}><StationList stations={favorites.list} onStationSelected={station=> this.stationSelected(station)} ></StationList></div> },\r\n            { title: \"Playing\", content: (cls:string) => <RadioPlayerUI className={cls} station={this.state.selectedStation}></RadioPlayerUI> },\r\n            { title: \"About\", content: (cls:string) => <About className={cls} ></About>},\r\n        ]\r\n    }\r\n\r\n    private searchTab:Tab = { title: \"Search\", content: (cls:string) => <RadioSearch className={cls} search={currentSearch} onStationSelected={station=> this.stationSelected(station)}>Search content</RadioSearch> }\r\n\r\n    changeTab(tab:Tab, userSelect=true)  {\r\n        this.setState({\r\n            selectedTab: tab.title\r\n        })\r\n        if (userSelect) {\r\n            this.setState({\r\n                selectedStation: radioPlayer.station\r\n            })\r\n        }\r\n    }\r\n\r\n    stationSelected(station:Station) {\r\n        this.setState({\r\n            selectedStation: station\r\n        })\r\n        // todo: should use rather tab id\r\n        this.changeTab(this.tabs[1], /*userSelect*/false)  \r\n    }\r\n\r\n    searchTextChanged(e) {\r\n        const query = e.target.value;\r\n        currentSearch.scheduleSearch(query)\r\n    }\r\n\r\n    private searchInput = React.createRef<HTMLInputElement>()\r\n    private focusOnSearch = false\r\n    selectSearch() {\r\n        this.changeTab(this.searchTab)\r\n        this.focusOnSearch = true\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        if (this.focusOnSearch && this.searchInput.current) {\r\n            this.searchInput.current.focus()\r\n            this.focusOnSearch = false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const tabs = this.tabs\r\n        const selectedTabName = this.state.selectedTab\r\n        const selectedTab = tabs.find(tab => tab.title === selectedTabName) || this.searchTab\r\n        \r\n        const tabTitles = tabs.map(tab => {\r\n                    let selection = (selectedTab == tab) ? <span className=\"selection\"></span> : undefined\r\n                    return <div className=\"tab flexible vertical\"\r\n                               key={tab.title} onClick={e=>this.changeTab(tab)} >\r\n                                    <span className=\"title\">{tab.title}</span>\r\n                                    {selection}\r\n                           </div> \r\n        })\r\n        const allTabs = [this.searchTab].concat(tabs)\r\n        const tabContent = allTabs.map(tab => tab.content(tab == selectedTab ? \"visible\" : \"hidden\"))\r\n        const searchSelected = this.searchTab == selectedTab;\r\n        \r\n        return (\r\n            <div className=\"radio-App\">\r\n                <div id=\"top\" className=\"flexible vertical radio\">\r\n                    <div className=\"header flexible horizontal\">\r\n                        <img className=\"logo\" src=\"/webradio/logo.svg\"></img>\r\n                        <span className={`divider ${searchSelected ? \"blinking\" : \"static\"}`}></span>\r\n                        <span className={`currently-playing ${searchSelected ? \"hidden\" : \"visible\"}`}>\r\n                            {radioPlayer.station?.name}\r\n                        </span>\r\n                        <input className={`search flex1 ${searchSelected ? \"visible\" : \"hidden\"}`} \r\n                            ref={this.searchInput}\r\n                            defaultValue={currentSearch.searchText} \r\n                            onInput={ (e) => { this.searchTextChanged(e) } }>\r\n                        </input>\r\n                    </div>\r\n                    <div className=\"tabs flexible horizontal\">\r\n                        <span className=\"flex1\"></span>\r\n                        {tabTitles}\r\n                        <span className=\"flex1\"></span>\r\n                        <a className=\"search-tab\" onClick={e=> this.selectSearch()}>\r\n                            <img className=\"icon search\" src=\"/webradio/icons/search.svg\"></img>\r\n                        </a>\r\n                    </div>\r\n                </div>\r\n                <div id=\"content\" className=\"radio flexible vertical\">\r\n                    {tabContent}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import { RadioSearch } from \"./radioApi\";\r\nimport { SubscriptionRepository, Subscription } from \"../models/base\";\r\n\r\n\r\nexport default class Search  {\r\n    private subs = new SubscriptionRepository()\r\n    private searchTimer\r\n    private currentSearch:RadioSearch|undefined\r\n\r\n    get searchText() {\r\n        return this.currentSearch ? this.currentSearch.query.name : \"\"\r\n    }\r\n\r\n    async scheduleSearch(query:string, timeout = 400) {\r\n        this.searchTimer = clearTimeout(this.searchTimer)\r\n        this.searchTimer = setTimeout(async () => {\r\n            let search = new RadioSearch({name: query})\r\n            this.currentSearch = search\r\n            this.subs.notifyFor(\"searching\", true)\r\n            await search.search()\r\n            this.subs.notifyFor(\"query\", undefined) // search query changed\r\n            this.subs.notifyFor(\"searching\", false)\r\n            this.subs.notifyFor(\"results\", search.results)\r\n        }, timeout)\r\n    }\r\n\r\n    async loadMoreResults() {\r\n        if (this.currentSearch && this.currentSearch.hasMoreResults) {\r\n            this.subs.notifyFor(\"searching\", true)\r\n            await this.currentSearch.search()\r\n            this.subs.notifyFor(\"searching\", false)\r\n            this.subs.notifyFor(\"results\", this.currentSearch.results)\r\n        }\r\n    }\r\n\r\n    subscribe(prop: \"searching\" | \"results\" | \"query\", changeFunc:(newVal:any) => void):Subscription {\r\n        return this.subs.add(prop, changeFunc)\r\n    }\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport WebRadio from './webradio'\n\nReactDOM.render(\n  <React.StrictMode>\n    <WebRadio>my text</WebRadio>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}